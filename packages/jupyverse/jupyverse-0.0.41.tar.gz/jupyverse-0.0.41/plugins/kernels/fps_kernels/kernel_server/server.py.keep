import os
import json
import asyncio
import signal
from datetime import datetime
from typing import Iterable, Optional, Union, List, Dict, cast

from fastapi import WebSocket, WebSocketDisconnect  # type: ignore
from starlette.websockets import WebSocketState
from zmq.sugar.socket import Socket

from .connect import (
    write_connection_file as _write_connection_file,
    read_connection_file,
    launch_kernel,
    connect_channel,
    cfg_t,
)  # type: ignore
from .message import (
    receive_message,
    send_message,
    create_message,
    to_binary,
    from_binary,
)  # type: ignore


kernels: dict = {}


class KernelServer:
    def __init__(
        self,
        kernelspec_path: str = "",
        connection_cfg: Optional[cfg_t] = None,
        connection_file: str = "",
        write_connection_file: bool = True,
        capture_kernel_output: bool = True,
    ) -> None:
        self.capture_kernel_output = capture_kernel_output
        self.kernelspec_path = kernelspec_path
        if write_connection_file:
            self.connection_file_path, self.connection_cfg = _write_connection_file(
                connection_file
            )
        elif connection_file:
            self.connection_file_path = connection_file
            self.connection_cfg = read_connection_file(connection_file)
        else:
            assert connection_cfg is not None
            self.connection_cfg = connection_cfg
        self.key = cast(str, self.connection_cfg["key"])
        self.sessions: Dict[str, Dict[str, Union[WebSocket, Socket()]]] = {}
        # blocked messages and allowed messages are mutually exclusive
        self.blocked_messages: List[str] = []
        self.allowed_messages: Optional[
            List[str]
        ] = None  # when None, all messages are allowed
        # when [], no message is allowed

    def block_messages(self, message_types: Iterable[str] = []):
        # if using blocked messages, discard allowed messages
        self.allowed_messages = None
        if isinstance(message_types, str):
            message_types = [message_types]
        self.blocked_messages = list(message_types)

    def allow_messages(self, message_types: Optional[Iterable[str]] = None):
        # if using allowed messages, discard blocked messages
        self.blocked_messages = []
        if message_types is None:
            self.allowed_messages = None
            return
        if isinstance(message_types, str):
            message_types = [message_types]
        self.allowed_messages = list(message_types)

    @property
    def connections(self) -> int:
        return len(self.sessions)

    async def start(self) -> None:
        if not self.kernelspec_path:
            raise RuntimeError(
                "Could not find a kernel, maybe you forgot to install one?"
            )
        self.last_activity = {
            "date": datetime.utcnow().isoformat() + "Z",
            "execution_state": "starting",
        }
        self.kernel_process = await launch_kernel(
            self.kernelspec_path, self.connection_file_path, self.capture_kernel_output
        )

    async def stop(self, clear_sessions: bool = True) -> None:
        for tasks in [session["tasks"] for session in self.sessions.values()]:
            for task in tasks:
                task.cancel()
            tasks.remove(task)
        if clear_sessions:
            self.sessions = {}
        # FIXME: stop kernel in a better way
        try:
            self.kernel_process.send_signal(signal.SIGINT)
            self.kernel_process.kill()
            await self.kernel_process.wait()
        except Exception:
            pass
        try:
            os.remove(self.connection_file_path)
        except Exception:
            pass

    async def restart(self) -> None:
        await self.stop(clear_sessions=False)
        await self.start()
        for session in self.sessions.values():
            session["shell"] = connect_channel("shell", self.connection_cfg)
            session["control"] = connect_channel("control", self.connection_cfg)
            session["iopub"] = connect_channel("iopub", self.connection_cfg)
            await self._wait_for_ready(session)
            tasks = [
                asyncio.create_task(self.listen("shell", session)),
                asyncio.create_task(self.listen("control", session)),
                asyncio.create_task(self.listen("iopub", session)),
            ]
            session["tasks"] += tasks

    async def serve(self, websocket: WebSocket, session_id: str):
        session = {
            "web": websocket,
            "shell": connect_channel("shell", self.connection_cfg),
            "control": connect_channel("control", self.connection_cfg),
            "iopub": connect_channel("iopub", self.connection_cfg),
            "tasks": [],
        }
        self.sessions[session_id] = session
        await self._wait_for_ready(session)
        tasks = [
            asyncio.create_task(self.listen("shell", session)),
            asyncio.create_task(self.listen("control", session)),
            asyncio.create_task(self.listen("iopub", session)),
        ]
        session["tasks"] += tasks
        await self.listen_web(session)
        for task in session["tasks"]:
            task.cancel()
        del self.sessions[session_id]

    async def listen_web(self, session: Dict[str, Union[WebSocket, Socket]]):
        try:
            while True:
                msg = await receive_json_or_bytes(session["web"])
                msg_type = msg["header"]["msg_type"]
                if (msg_type in self.blocked_messages) or (
                    self.allowed_messages is not None
                    and msg_type not in self.allowed_messages
                ):
                    continue
                channel = msg.pop("channel")
                send_message(msg, session[channel], self.key)
        except WebSocketDisconnect:
            pass

    async def listen(self, channel: str, session: Dict[str, Union[WebSocket, Socket]]):
        while True:
            msg = await receive_message(session[channel])
            msg["channel"] = channel
            await send_json_or_bytes(session["web"], msg)
            if channel == "iopub":
                if "content" in msg and "execution_state" in msg["content"]:
                    self.last_activity = {
                        "date": msg["header"]["date"],
                        "execution_state": msg["content"]["execution_state"],
                    }

    async def _wait_for_ready(self, session: Dict[str, Union[WebSocket, Socket]]):
        while True:
            msg = create_message("kernel_info_request")
            send_message(msg, session["shell"], self.key)
            msg = await receive_message(session["shell"], 0.2)
            if msg is not None and msg["header"]["msg_type"] == "kernel_info_reply":
                msg = await receive_message(session["iopub"], 0.2)
                if msg is None:
                    # IOPub not connected, start over
                    pass
                else:
                    return


async def receive_json_or_bytes(websocket):
    assert websocket.application_state == WebSocketState.CONNECTED
    message = await websocket.receive()
    websocket._raise_on_disconnect(message)
    if "text" in message:
        return json.loads(message["text"])
    msg = from_binary(message["bytes"])
    return msg


async def send_json_or_bytes(websocket, msg):
    bmsg = to_binary(msg)
    if bmsg is None:
        await websocket.send_json(msg)
    else:
        await websocket.send_bytes(bmsg)
