# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['asynckivy']

package_data = \
{'': ['*']}

install_requires = \
['asyncgui>=0.5,<0.6']

setup_kwargs = {
    'name': 'asynckivy',
    'version': '0.6.0.dev0',
    'description': 'Async library for Kivy',
    'long_description': '# AsyncKivy\n\n[Youtube](https://www.youtube.com/playlist?list=PLNdhqAjzeEGjTpmvNck4Uykps8s9LmRTJ)  \n[日本語doc](README_jp.md)  \n\n`asynckivy` is an async library that saves you from ugly callback-based code,\nlike most of async libraries do.\nLet\'s say you want to do:\n\n1. `print(\'A\')`\n1. wait for 1sec\n1. `print(\'B\')`\n1. wait for a button to be pressed\n1. `print(\'C\')`\n\nin that order.\nYour code would look like this:\n\n```python\nfrom kivy.clock import Clock\n\ndef what_you_want_to_do(button):\n    print(\'A\')\n\n    def one_sec_later(__):\n        print(\'B\')\n        button.bind(on_press=on_button_press)\n    Clock.schedule_once(one_sec_later, 1)\n\n    def on_button_press(button):\n        button.unbind(on_press=on_button_press)\n        print(\'C\')\n```\n\nIt\'s not easy to understand.\nIf you use `asynckivy`, the above code will become:\n\n```python\nimport asynckivy as ak\n\nasync def what_you_want_to_do(button):\n    print(\'A\')\n    await ak.sleep(1)\n    print(\'B\')\n    await ak.event(button, \'on_press\')\n    print(\'C\')\n```\n\n## Installation\n\nIt\'s recommended to pin the minor version, because if it changed, it means some *important* breaking changes occurred.\n\n```text\npoetry add asynckivy@~0.5\npip install "asynckivy>=0.5,<0.6"\n```\n\n## Usage\n\n```python\nimport asynckivy as ak\n\nasync def some_task(button):\n    # wait for 1sec\n    dt = await ak.sleep(1)\n    print(f\'{dt} seconds have passed\')\n\n    # wait until a button is pressed\n    await ak.event(button, \'on_press\')\n\n    # wait until \'button.x\' changes\n    __, x = await ak.event(button, \'x\')\n    print(f\'button.x is now {x}\')\n\n    # wait until \'button.x\' becomes greater than 100\n    if button.x <= 100:\n        __, x = await ak.event(button, \'x\', filter=lambda __, x: x>100)\n        print(f\'button.x is now {x}\')\n\n    # wait until EITHER a button is pressed OR 5sec passes.\n    # i.e. wait at most 5 seconds for a button to be pressed\n    tasks = await ak.or_(\n        ak.event(button, \'on_press\'),\n        ak.sleep(5),\n    )\n    print("The button was pressed" if tasks[0].done else "Timeout")\n\n    # wait until a button is pressed AND 5sec passes.\n    tasks = await ak.and_(\n        ak.event(button, \'on_press\'),\n        ak.sleep(5),\n    )\n\n    # nest as you want.\n    # wait for a button to be pressed AND (5sec OR \'other_async_func\' to complete)\n    tasks = await ak.and_(\n        ak.event(button, \'on_press\'),\n        ak.or_(\n            ak.sleep(5),\n            other_async_func(),\n        ),\n    )\n    child_tasks = tasks[1].result\n    print("5sec passed" if child_tasks[0].done else "other_async_func has completed")\n\nak.start(some_task(some_button))\n```\n\n### animation\n\n```python\nfrom types import SimpleNamespace\nimport asynckivy as ak\n\nasync def async_func(widget1, widget2):\n    obj = SimpleNamespace(attr1=10, attr2=[20, 30, ], attr3={\'key\': 40, })\n\n    # Animate attibutes of any object and wait for it to end.\n    await ak.animate(obj, attr1=200, attr2=[200, 100], attr3={\'key\': 400})\n\n    # Interpolate between two values in an async-manner.\n    async for v in ak.interpolate(0, 200):\n        print(v)\n        # await something  # DO NOT await anything during this loop\n\n    # fade-out widgets, excute the with-block, fade-in widgets.\n    async with ak.fade_transition(widget1, widget2):\n        widget.text = \'new text\'\n        widget2.y = 200\n\n    # If you want more low-level control over animations, use the vanim module.\n    # Read the module doc for details.\n    from asynckivy import vanim\n    async for dt in vanim.delta_time():\n        ...\n```\n\n### touch handling\n\nYou can easily handle `on_touch_xxx` events via `asynckivy.rest_of_touch_moves()`.\n\n```python\nclass TouchReceiver(Widget):\n    def on_touch_down(self, touch):\n        if self.collide_point(*touch.opos):\n            ak.start(self.handle_touch(touch))\n            return True\n\n    async def handle_touch(self, touch):\n        print(\'on_touch_up\')\n        async for __ in ak.rest_of_touch_moves(self, touch):\n            # await something  # DO NOT await anything during this loop\n            print(\'on_touch_move\')\n        print(\'on_touch_up\')\n```\n\nIf Kivy is running in asyncio/trio mode, `rest_of_touch_moves()` might not work.\nIn that case, use `watch_touch()`.\n\n```python\nimport asynckivy as ak\n\nclass TouchReceiver(Widget):\n    def on_touch_down(self, touch):\n        if self.collide_point(*touch.opos):\n            ak.start(self.handle_touch(touch))\n            return True\n\n    async def handle_touch(self, touch):\n        print(\'on_touch_up\')\n        async with ak.watch_watch(widget, touch) as is_touch_move:\n            # DO NOT await anything inside this with-block except the return value of \'is_touch_move()\'.\n            while await is_touch_move():\n                print(\'on_touch_move\')\n        print(\'on_touch_up\')\n```\n\n### threading\n\n`asynckivy` does not have any I/O primitives like Trio and asyncio do,\nthus threads are the only way to perform them without blocking the main-thread:\n\n```python\nfrom concurrent.futures import ThreadPoolExecuter\nimport asynckivy as ak\n\nexecuter = ThreadPoolExecuter()\n\n\ndef thread_blocking_operation():\n    \'\'\'This function is called from outside the main-thread, so you are not allowed to touch gui components here.\'\'\'\n\n\nasync def some_task():\n    # create a new thread, run a function inside it, then\n    # wait for the completion of that thread\n    r = await ak.run_in_thread(thread_blocking_operation)\n    print("return value:", r)\n\n    # run a function inside a ThreadPoolExecuter, and wait for the completion\n    # (ProcessPoolExecuter is not supported)\n    r = await ak.run_in_executer(executer, thread_blocking_operation)\n    print("return value:", r)\n```\n\nExceptions(not BaseExceptions) are propagated to the caller\nso you can catch them like you do in synchronous code:\n\n```python\nimport requests\nimport asynckivy as ak\n\nasync def some_task(label):\n    try:\n        response = await ak.run_in_thread(lambda: requests.get(\'htt...\', timeout=10))\n    except requests.Timeout:\n        label.text = "TIMEOUT!"\n    else:\n        label.text = "RECEIVED: " + response.text\n```\n\n### synchronizing and communicating between tasks\n\nThere is a [trio.Event](https://trio.readthedocs.io/en/stable/reference-core.html#trio.Event) equivalent.\n\n```python\nimport asynckivy as ak\n\nasync def task_A(e):\n    print(\'A1\')\n    await e.wait()\n    print(\'A2\')\nasync def task_B(e):\n    print(\'B1\')\n    await e.wait()\n    print(\'B2\')\n\ne = ak.Event()\nak.start(task_A(e))\n# A1\nak.start(task_B(e))\n# B1\ne.set()\n# A2\n# B2\n```\n\nUnlike Trio\'s and asyncio\'s, when you call ``Event.set()``,\nthe tasks waiting for it to happen will *immediately* be resumed.\nAs a result, ``e.set()`` will return *after* ``A2`` and ``B2`` are printed.\n\nAnd there is an [asyncio.Queue](https://docs.python.org/3/library/asyncio-queue.html) equivalent.\n\n```python\nfrom kivy.app import App\nimport asynckivy as ak\nfrom asynckivy.queue import Queue\n\nasync def producer(q, items):\n    for i in items:\n        await q.put(i)\n    q.close()\n\nasync def consumer(q):\n    assert \'\'.join([item async for item in q]) == \'ABCD\'  # Queue is async-iterable\n\nasync def consumer2(q):\n    \'\'\'The ``consumer()`` above can be written in more primitive way like this\'\'\'\n    items = []\n    try:\n        while True:\n            items.append(await q.get())\n    except ak.EndOfResource:\n        assert \'\'.join(items) == \'ABCD\'\n\n\nq = Queue()\nak.start(producer(q, \'ABCD\'))\nak.start(consumer(q))\nApp().run()  # Queue relies on Clock so you need to run the event-loop\n```\n\n### dealing with cancellations\n\n``asynckivy.start()`` returns a ``Task``,\nwhich can be used to cancel the execution.\n\n```python\ntask = asynckivy.start(async_func())\n...\ntask.cancel()\n```\n\nWhen `.cancel()` is called, `GeneratorExit` will occur inside the task,\nwhich means you can prepare for cancellations as follows:\n\n```python\nasync def async_func():\n    try:\n        ...\n    except GeneratorExit:\n        print(\'cancelled\')\n        raise  # You must re-raise !!\n    finally:\n        print(\'cleanup resources here\')\n```\n\nYou are not allowed to `await` inside `except-GeneratorExit-clause` and `finally-clause` if you want the task to be cancellable\nbecause cancellations always must be done immediately.\n\n```python\nasync def async_func():\n    try:\n        await something  # <-- ALLOWED\n    except Exception:\n        await something  # <-- ALLOWED\n    except GeneratorExit:\n        await something  # <-- NOT ALLOWED\n        raise\n    finally:\n        await something  # <-- NOT ALLOWED\n```\n\nYou are allowed to `await` inside `finally-clause` if the task will never get cancelled.\n\n```python\nasync def async_func():  # Assuming this never gets cancelled\n    try:\n        await something  # <-- ALLOWED\n    except Exception:\n        await something  # <-- ALLOWED\n    finally:\n        await something  # <-- ALLOWED\n```\n\nAs long as you follow the above rules, you can cancel tasks as you wish.\nBut note that if there are lots of explicit calls to `Task.cancel()` in your code,\n**it\'s a sign of your code being not well-structured**.\nYou can usually avoid it by using `asynckivy.and_()` and `asynckivy.or_()`.  \n\n### misc\n\n```python\nimport asynckivy as ak\n\n# schedule an awaitable/Task to start after the next frame\nak.start_soon(awaitable_or_task)\n```\n\n## Notes\n\n### Places you cannot await\n\nI already mentioned about this but I\'ll say again.\n**You cannot await while iterating `rest_of_touch_moves()` or `interpolate()`.**\n\n```python\nimport asynckivy as ak\n\nasync def async_fn():\n    async for v in ak.interpolate(...):\n        await something  # <-- NOT ALLOWED\n\n    async for __ in ak.rest_of_touch_moves(...):\n        await something  # <-- NOT ALLOWED\n```\n\n### Some of features might not work if Kivy is running in asyncio/trio mode\n\n`asyncio` and `trio` do some hacky stuff, `sys.set_asyncgen_hooks()` and `sys.get_asyncgen_hooks`,\nwhich likely hinders asynckivy-flavored async generators.\nYou can see its details [here](https://peps.python.org/pep-0525/#finalization).\n\nBecause of that, the features that create async generators might not work perfectly.\nHere is a list of them:\n\n- `rest_of_touch_moves()`\n- the entire `vanim` module\n- `fade_transition()`\n\nI don\'t know how to make it work.\nMaybe if [PEP355](https://peps.python.org/pep-0533/) is accepted,\nit might work.\n\n### Structured Concurrency\n\n(This section is incomplete, and will be filled some day.)\n\n`asynckivy.and_()` and `asynckivy.or_()` follow the concept of [structured concurrency][njs_sc].\n\n```python\nimport asynckivy as ak\n\nasync def root():\n    await ak.or_(child1(), child2())\n\nasync def child1():\n    ...\n\nasync def child2():\n    await ak.and_(ground_child1(), ground_child2())\n\nasync def ground_child1():\n    ...\n\nasync def ground_child2():\n    ...\n```\n\n```mermaid\nflowchart TB\nroot --> C1(child 1) & C2(child 2)\nC2 --> GC1(ground child 1) & GC2(ground child 2)\n```\n\n\n## Tested on\n\n- CPython 3.7 + Kivy 2.1.0\n- CPython 3.8 + Kivy 2.1.0\n- CPython 3.9 + Kivy 2.1.0\n- CPython 3.10 + Kivy 2.1.0\n\n## Why this even exists\n\nKivy supports two legit async libraries, [asyncio][asyncio] and [Trio][trio], from version 2.0.0 so developing another one seems [reinventing the wheel][reinventing].\nActually, I started this one just for learning how async/await works so it *was* initially "reinventing the wheel".\n\nBut after playing with Trio and Kivy for a while, I noticed that Trio is not suitable for the situation where fast reactions are required e.g. touch events.\nThe same is true of asyncio.\nYou can confirm it by running `investigation/why_xxx_is_not_suitable_for_handling_touch_events.py`, and mashing a mouse button.\nYou\'ll see sometimes `up` is not paired with `down`.\nYou\'ll see the coordinates aren\'t relative to the `RelativeLayout` even though the `target` belongs to it.\n\nThe cause of those problems is that `trio.Event.set()` and `asyncio.Event.set()` don\'t *immediately* resume the tasks waiting for the `Event` to be set. They just schedule the tasks to resume.\nSame thing can be said to `nursery.start_soon()` and `asyncio.create_task()`.\n\nTrio and asyncio are async **I/O** libraries after all. They probably don\'t have to immediately resumes/starts tasks, which I think necessary for Kivy\'s touch handling.\n(If a touch is not handled immediately, its coordinate\'s origin may change, its `pos` might be updated and the previous value will be lost.)\nTheir core design might not be suitable for GUI in the first place.\nThat\'s why I\'m still developing this `asynckivy` library to this day.\n\n[asyncio]:https://docs.python.org/3/library/asyncio.html\n[trio]:https://trio.readthedocs.io/en/stable/\n[reinventing]:https://en.wikipedia.org/wiki/Reinventing_the_wheel\n[njs_sc]:https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/\n',
    'author': 'Nattōsai Mitō',
    'author_email': 'flow4re2c@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/gottadiveintopython/asynckivy',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
