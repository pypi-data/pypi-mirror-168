import{C as t,c as e,e as a,b as i,d as s,t as r,f as n,g as o,h,E as l,R as g,D as c,i as d,j as f,S as w,k as u,l as p,m,n as y,o as b,p as I,q as S,r as _,F,u as B,v as k,w as D,x as R,y as C,z as U,A as E,B as T,G as v,H as $,I as A,J as z,M as V,K as P,L as x,N as L,O as M,P as O,Q as W,T as j,U as q,V as H}from"./c.21ed9449.js";const N=async n=>{let o;return n==t?o=await import("./c.97eb4c8f.js"):n==e?o=await import("./c.6c278151.js"):n==a?o=await import("./c.acc482d6.js"):n==i?o=await import("./c.b7e442f6.js"):n==s&&(o=await import("./c.c6a70a64.js")),{...o,text:r(atob(o.text)),data:r(atob(o.data))}},Q={b:{u:DataView.prototype.getInt8,p:DataView.prototype.setInt8,bytes:1},B:{u:DataView.prototype.getUint8,p:DataView.prototype.setUint8,bytes:1},h:{u:DataView.prototype.getInt16,p:DataView.prototype.setInt16,bytes:2},H:{u:DataView.prototype.getUint16,p:DataView.prototype.setUint16,bytes:2},i:{u:DataView.prototype.getInt32,p:DataView.prototype.setInt32,bytes:4},I:{u:DataView.prototype.getUint32,p:DataView.prototype.setUint32,bytes:4},q:{u:DataView.prototype.getInt64,p:DataView.prototype.setInt64,bytes:8},Q:{u:DataView.prototype.getUint64,p:DataView.prototype.setUint64,bytes:8}},G=(t,...e)=>{let a=0;if(t.replace(/[<>]/,"").length!=e.length)throw"Pack format to Argument count mismatch";let i=[],s=!0;for(let i=0;i<t.length;i++)"<"==t[i]?s=!0:">"==t[i]?s=!1:(r(t[i],e[a]),a++);function r(t,e){if(!(t in Q))throw"Unhandled character '"+t+"' in pack format";let a=Q[t].bytes,r=new DataView(new ArrayBuffer(a));Q[t].p.bind(r)(0,e,s);for(let t=0;t<a;t++)i.push(r.getUint8(t))}return i},J=(t,e)=>{let a=0,i=[],s=!0;for(let e of t)"<"==e?s=!0:">"==e?s=!1:r(e);function r(t){if(!(t in Q))throw"Unhandled character '"+t+"' in unpack format";let r=Q[t].bytes,n=new DataView(new ArrayBuffer(r));for(let t=0;t<r;t++)n.setUint8(t,255&e[a+t]);let o=Q[t].u.bind(n);i.push(o(0,s)),a+=r}return i};class K extends EventTarget{constructor(t,e,a){super(),this.port=t,this.logger=e,this._parent=a,this.chipName=null,this._efuses=new Array(4).fill(0),this._flashsize=4194304,this.debug=!1,this.IS_STUB=!1,this.connected=!0,this.flashSize=null}get _inputBuffer(){return this._parent?this._parent._inputBuffer:this.__inputBuffer}async initialize(){await this.hardReset(!0),this._parent||(this.__inputBuffer=[],this.readLoop()),await this.sync();let t=await this.readRegister(n),e=M[t>>>0];if(void 0===e)throw new Error(`Unknown Chip: Hex: ${o(t>>>0,8).toLowerCase()} Number: ${t}`);this.chipName=e.name,this.chipFamily=e.family;let a=h(this.getChipFamily()).macFuse;for(let t=0;t<4;t++)this._efuses[t]=await this.readRegister(a+4*t);this.logger.log(`Chip type ${this.chipName}`)}async readLoop(){this.debug&&this.logger.debug("Starting read loop"),this._reader=this.port.readable.getReader();try{for(;;){const{value:t,done:e}=await this._reader.read();if(e){this._reader.releaseLock();break}t&&0!==t.length&&this._inputBuffer.push(...Array.from(t))}}catch(t){console.error("Read loop got disconnected")}this.connected=!1,this.dispatchEvent(new Event("disconnect")),this.logger.debug("Finished read loop")}async hardReset(t=!1){this.logger.log("Try hard reset."),await this.port.setSignals({dataTerminalReady:!1,requestToSend:!0}),await this.port.setSignals({dataTerminalReady:t,requestToSend:!1}),await new Promise((t=>setTimeout(t,1e3)))}macAddr(){let r,n=new Array(6).fill(0),o=this._efuses[0],h=this._efuses[1],l=this._efuses[2],g=this._efuses[3];if(this.chipFamily==i){if(0!=g)r=[g>>16&255,g>>8&255,255&g];else if(0==(h>>16&255))r=[24,254,52];else{if(1!=(h>>16&255))throw new Error("Couldnt determine OUI");r=[172,208,116]}n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=h>>8&255,n[4]=255&h,n[5]=o>>24&255}else if(this.chipFamily==t)n[0]=l>>8&255,n[1]=255&l,n[2]=h>>24&255,n[3]=h>>16&255,n[4]=h>>8&255,n[5]=255&h;else{if(this.chipFamily!=e&&this.chipFamily!=a&&this.chipFamily!=s)throw new Error("Unknown chip family");n[0]=h>>8&255,n[1]=255&h,n[2]=o>>24&255,n[3]=o>>16&255,n[4]=o>>8&255,n[5]=255&o}return n}async readRegister(t){this.debug&&this.logger.debug("Reading from Register "+o(t,8));let e=G("<I",t);await this.sendCommand(l,e);let[a,i]=await this.getResponse(l);return a}async checkCommand(r,n,h=0,l=c){l=Math.min(l,O),await this.sendCommand(r,n,h);let[d,f]=await this.getResponse(r,l);if(null===f)throw new Error("Didn't get enough status bytes");let w=0;if(this.IS_STUB||this.chipFamily==i?w=2:[t,e,a,s].includes(this.chipFamily)?w=4:[2,4].includes(f.length)&&(w=f.length),f.length<w)throw new Error("Didn't get enough status bytes");let u=f.slice(-w,f.length);if(f=f.slice(0,-w),this.debug&&(this.logger.debug("status",u),this.logger.debug("value",d),this.logger.debug("data",f)),1==u[0])throw u[1]==g?new Error("Invalid (unsupported) command "+o(r)):new Error("Command failure error code "+o(u[1]));return[d,f]}async sendCommand(t,e,a=0){let i=d([...G("<BBHI",0,t,e.length,a),...e]);this.debug&&this.logger.debug(`Writing ${i.length} byte${1==i.length?"":"s"}:`,i),await this.writeToStream(i)}async readPacket(t){let e=null,a=!1,i=[];for(;;){let s=Date.now();for(i=[];Date.now()-s<t;){if(this._inputBuffer.length>0){i.push(this._inputBuffer.shift());break}await f(10)}if(0==i.length){throw new w("Timed out waiting for packet "+(null===e?"header":"content"))}this.debug&&this.logger.debug("Read "+i.length+" bytes: "+u(i));for(let t of i)if(null===e){if(192!=t)throw this.debug&&(this.logger.debug("Read invalid data: "+u(i)),this.logger.debug("Remaining data in serial buffer: "+u(this._inputBuffer))),new w("Invalid head of packet ("+o(t)+")");e=[]}else if(a)if(a=!1,220==t)e.push(192);else{if(221!=t)throw this.debug&&(this.logger.debug("Read invalid data: "+u(i)),this.logger.debug("Remaining data in serial buffer: "+u(this._inputBuffer))),new w("Invalid SLIP escape (0xdb, "+o(t)+")");e.push(219)}else if(219==t)a=!0;else{if(192==t)return this.debug&&this.logger.debug("Received full packet: "+u(e)),e;e.push(t)}}throw new w("Invalid state")}async getResponse(t,e=c){for(let a=0;a<100;a++){const a=await this.readPacket(e);if(a.length<8)continue;const[i,s,r,n]=J("<BBHI",a.slice(0,8));if(1!=i)continue;const h=a.slice(8);if(null==t||s==t)return[n,h];if(0!=h[0]&&h[1]==g)throw this._inputBuffer.length=0,new Error(`Invalid (unsupported) command ${o(t)}`)}throw"Response doesn't match request"}checksum(t,e=p){for(let a of t)e^=a;return e}async setBaudrate(t){if(this.chipFamily==i)throw new Error("Changing baud rate is not supported on the ESP8266");this.logger.log("Attempting to change baud rate to "+t+"...");try{let e=G("<II",t,this.IS_STUB?m:0);await this.checkCommand(y,e)}catch(e){throw console.error(e),new Error(`Unable to change the baud rate to ${t}: No response from set baud rate command.`)}this._parent?await this._parent.reconfigurePort(t):await this.reconfigurePort(t)}async reconfigurePort(t){var e;try{await(null===(e=this._reader)||void 0===e?void 0:e.cancel()),await this.port.close(),await this.port.open({baudRate:t}),this.readLoop(),this.logger.log(`Changed baud rate to ${t}`)}catch(e){throw console.error(e),new Error(`Unable to change the baud rate to ${t}: ${e}`)}}async sync(){for(let t=0;t<5;t++){if(this._inputBuffer.length=0,await this._sync())return await f(100),!0;await f(100)}throw new Error("Couldn't sync to ESP. Try resetting.")}async _sync(){await this.sendCommand(b,I);for(let t=0;t<8;t++)try{let[t,e]=await this.getResponse(b,S);if(e.length>1&&0==e[0]&&0==e[1])return!0}catch(t){}return!1}getFlashWriteSize(){return this.IS_STUB?_:F}async flashData(t,e,a=0,i=!1){if(t.byteLength>=8){var s=Array.from(new Uint8Array(t,0,4));let e=s[0],a=s[2],i=s[3];this.logger.log(`Image header, Magic=${o(e)}, FlashMode=${o(a)}, FlashSizeFreq=${o(i)}`)}let r,n=t.byteLength,h=0,l=c;i?(r=B(new Uint8Array(t),{level:9}).buffer,h=r.byteLength,this.logger.log(`Writing data with filesize: ${n}. Compressed Size: ${h}`),l=await this.flashDeflBegin(n,h,a)):(this.logger.log(`Writing data with filesize: ${n}`),r=t,await this.flashBegin(n,a));let g=[],d=0,f=0,w=0,u=Date.now(),p=this.getFlashWriteSize(),m=i?h:n;for(;m-w>0;)this.debug&&this.logger.log(`Writing at ${o(a+d*p,8)} `),m-w>=p?g=Array.from(new Uint8Array(r,w,p)):(g=Array.from(new Uint8Array(r,w,m-w)),i||(g=g.concat(new Array(p-g.length).fill(255)))),i?await this.flashDeflBlock(g,d,l):await this.flashBlock(g,d),d+=1,f+=i?Math.round(g.length*n/h):g.length,w+=p,e(Math.min(f,n),n);this.logger.log("Took "+(Date.now()-u)+"ms to write "+m+" bytes"),this.IS_STUB&&(await this.flashBegin(0,0),i?await this.flashDeflFinish():await this.flashFinish())}async flashBlock(t,e,a=c){await this.checkCommand(k,G("<IIII",t.length,e,0,0).concat(t),this.checksum(t),a)}async flashDeflBlock(t,e,a=c){await this.checkCommand(D,G("<IIII",t.length,e,0,0).concat(t),this.checksum(t),a)}async flashBegin(r=0,n=0,h=!1){let l,g,d=this.getFlashWriteSize();!this.IS_STUB&&[t,e,a,s].includes(this.chipFamily)&&await this.checkCommand(R,new Array(8).fill(0));let f,w=Math.floor((r+d-1)/d);l=this.chipFamily==i?this.getEraseSize(n,r):r,f=this.IS_STUB?c:W(H,r);let u=Date.now();return g=G("<IIII",l,w,d,n),this.chipFamily!=t&&this.chipFamily!=e&&this.chipFamily!=a&&this.chipFamily!=s||(g=g.concat(G("<I",h?1:0))),this.logger.log("Erase size "+l+", blocks "+w+", block size "+o(d,4)+", offset "+o(n,4)+", encrypted "+(h?"yes":"no")),await this.checkCommand(C,g,0,f),0==r||this.IS_STUB||this.logger.log("Took "+(Date.now()-u)+"ms to erase "+w+" bytes"),w}async flashDeflBegin(t=0,e=0,a=0,i=!1){let s,r=this.getFlashWriteSize(),n=Math.floor((e+r-1)/r),o=Math.floor((t+r-1)/r),h=0,l=0;return this.IS_STUB?(h=t,l=W(H,h)):(h=o*r,l=c),s=G("<IIII",h,n,r,a),await this.checkCommand(U,s,0,l),l}async flashFinish(){let t=G("<I",1);await this.checkCommand(E,t)}async flashDeflFinish(){let t=G("<I",1);await this.checkCommand(T,t)}getBootloaderOffset(){return h(this.getChipFamily()).flashOffs}async flashId(){return await this.runSpiFlashCommand(159,[],24)}getChipFamily(){return this._parent?this._parent.chipFamily:this.chipFamily}async writeRegister(t,e,a=4294967295,i=0,s=0){let r=G("<IIII",t,e,a,i);s>0&&r.concat(G("<IIII",h(this.getChipFamily()).uartDateReg,0,0,s)),await this.checkCommand(v,r)}async setDataLengths(t,e,a){if(-1!=t.mosiDlenOffs){let i=t.regBase+t.mosiDlenOffs,s=t.regBase+t.misoDlenOffs;e>0&&await this.writeRegister(i,e-1),a>0&&await this.writeRegister(s,a-1)}else{let i=t.regBase+t.usr1Offs,s=(0==a?0:a-1)<<8|(0==e?0:e-1)<<17;await this.writeRegister(i,s)}}async waitDone(t,e){for(let a=0;a<10;a++){if(0==(await this.readRegister(t)&e))return}throw Error("SPI command did not complete in time")}async runSpiFlashCommand(t,e,a=0){let i=h(this.getChipFamily()),s=i.regBase,r=s,n=s+i.usrOffs,l=s+i.usr2Offs,g=s+i.w0Offs,c=1<<18;if(a>32)throw new Error("Reading more than 32 bits back from a SPI flash operation is unsupported");if(e.length>64)throw new Error("Writing more than 64 bytes of data with one SPI command is unsupported");let d=8*e.length,f=await this.readRegister(n),w=await this.readRegister(l),u=1<<31;if(a>0&&(u|=268435456),d>0&&(u|=134217728),await this.setDataLengths(i,d,a),await this.writeRegister(n,u),await this.writeRegister(l,7<<28|t),0==d)await this.writeRegister(g,0);else{e.concat(new Array(e.length%4).fill(0));let t=J("I".repeat(Math.floor(e.length/4)),e),a=g;this.logger.debug(`Words Length: ${t.length}`);for(const e of t)this.logger.debug(`Writing word ${o(e)} to register offset ${o(a)}`),await this.writeRegister(a,e),a+=4}await this.writeRegister(r,c),await this.waitDone(r,c);let p=await this.readRegister(g);return await this.writeRegister(n,f),await this.writeRegister(l,w),p}async detectFlashSize(){this.logger.log("Detecting Flash Size");let t=await this.flashId(),e=255&t,a=t>>16&255;this.logger.log(`FlashId: ${o(t)}`),this.logger.log(`Flash Manufacturer: ${e.toString(16)}`),this.logger.log(`Flash Device: ${(t>>8&255).toString(16)}${a.toString(16)}`),this.flashSize=$[a],this.logger.log(`Auto-detected Flash size: ${this.flashSize}`)}getEraseSize(t,e){let a=j,i=Math.floor((e+a-1)/a),s=16-Math.floor(t/a)%16;return i<s&&(s=i),i<2*s?Math.floor((i+1)/2*a):(i-s)*a}async memBegin(t,e,a,i){return await this.checkCommand(A,G("<IIII",t,e,a,i))}async memBlock(t,e){return await this.checkCommand(z,G("<IIII",t.length,e,0,0).concat(t),this.checksum(t))}async memFinish(t=0){let e=this.IS_STUB?c:V,a=G("<II",0==t?1:0,t);return await this.checkCommand(P,a,0,e)}async runStub(){const t=await N(this.chipFamily);let e,a=q;this.logger.log("Uploading stub...");for(let e of["text","data"])if(Object.keys(t).includes(e)){let i=t[e+"_start"],s=t[e].length,r=Math.floor((s+a-1)/a);await this.memBegin(s,r,a,i);for(let i of Array(r).keys()){let r=i*a,n=r+a;n>s&&(n=s),await this.memBlock(t[e].slice(r,n),i)}}this.logger.log("Running stub..."),await this.memFinish(t.entry);const i=await this.readPacket(500);if(e=String.fromCharCode(...i),"OHAI"!=e)throw new Error("Failed to start stub. Unexpected response: "+e);this.logger.log("Stub is now running...");const s=new X(this.port,this.logger,this);return await s.detectFlashSize(),s}async writeToStream(t){const e=this.port.writable.getWriter();await e.write(new Uint8Array(t));try{e.releaseLock()}catch(t){console.error("Ignoring release lock error",t)}}async disconnect(){this._parent?await this._parent.disconnect():(await this.port.writable.getWriter().close(),await new Promise((t=>{this._reader||t(void 0),this.addEventListener("disconnect",t,{once:!0}),this._reader.cancel()})),this.connected=!1)}}class X extends K{constructor(){super(...arguments),this.IS_STUB=!0}async memBegin(t,e,a,i){let s=await N(this.chipFamily),r=i,n=i+t;console.log(r,n),console.log(s.data_start,s.data.length,s.text_start,s.text.length);for(let[t,e]of[[s.data_start,s.data_start+s.data.length],[s.text_start,s.text_start+s.text.length]])if(r<e&&n>t)throw new Error("Software loader is resident at "+o(t,8)+"-"+o(e,8)+". Can't load binary at overlapping address range "+o(r,8)+"-"+o(n,8)+". Try changing the binary loading address.")}async eraseFlash(){await this.checkCommand(x,[],0,L)}}const Y=async t=>{const e=await navigator.serial.requestPort();return t.log("Connecting..."),await e.open({baudRate:m}),t.log("Connected successfully."),new K(e,t)},Z=async t=>{import("./c.771d200b.js");const e=document.createElement("esphome-no-port-picked-dialog");return e.doTryAgain=t,document.body.append(e),!0};export{K as E,Y as c,Z as o};
