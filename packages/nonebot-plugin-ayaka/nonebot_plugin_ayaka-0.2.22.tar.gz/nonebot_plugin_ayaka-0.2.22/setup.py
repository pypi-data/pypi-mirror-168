# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['ayaka',
 'ayaka.adapter',
 'ayaka.core',
 'ayaka.core.inner_plugins',
 'ayaka.core.model']

package_data = \
{'': ['*']}

install_requires = \
['nonebot-adapter-onebot>=2.1.3,<3.0.0', 'nonebot2>=2.0.0b5,<3.0.0']

setup_kwargs = {
    'name': 'nonebot-plugin-ayaka',
    'version': '0.2.22',
    'description': 'a useful plugin providing convinient tools for the development of textual game on QQ',
    'long_description': '# Ayaka 0.2.22\n针对Nonebot2框架 Onebot_v11协议的文字游戏开发辅助插件\n\n<img src="https://img.shields.io/badge/python-3.8%2B-blue">\n\n<b>注意：由于更新pypi的readme.md需要占用版本号，因此其readme.md可能不是最新的，强烈建议读者前往[github仓库](https://github.com/bridgeL/nonebot-plugin-ayaka)以获取最新版本的帮助</b>\n\n0.2.8版本开始，无论是在[ayakabot](https://github.com/bridgeL/ayaka_bot)框架下书写的插件，还是在[nonebot2](https://github.com/nonebot/nonebot2)框架+ayaka插件(本仓库)下书写的插件（ayaka衍生插件），都可以相互通用\n\n[ayaka衍生插件合集](https://github.com/bridgeL/ayaka_games)\n\n# 更新记录\n\n<details>\n<summary>更新记录</summary>\n\n版本 | 备注\n-|-\n0.2.4 | 修复了ayaka优先级过高阻塞其他插件使用的问题\n0.2.8 | 取消了ayaka.lazy，之后统一使用`from ayaka import *`\n0.2.8 | ayaka提供的Bot具有新方法send_group_forward_msg，用于发送合并转发消息\n0.2.9 | ayaka正确地记录发送消息\n0.2.10 | 修复了发送base64编码图片时，ayaka内置插件record卡死的问题\n0.2.11 | 修复了内置插件valid能够关闭自己的问题，修复了每次重启后需要重新设置应用权限的问题，废弃了创建AyakaApp时的no_storage选项\n0.2.12 | 真正修复了每次重启后需要重新设置应用权限的问题\n0.2.13 | 修复了监听私聊失败的bug\n0.2.14 | 修复了内置插件record有时因为错误截断消息导致颜色标签不闭合的exception\n0.2.15 | 修复了监听私聊时，app.send()发送的默认目标设备错误的问题\n0.2.15 | 新增了内部插件，reboot，强制重启当前设备，用于某些错误情况下的脱离卡死\n0.2.16 | 修复了群聊间错误的上下文切换的bug\n0.2.18 | 修改了切换上下文的方法，现在，切换app将以回调所在的文件为准\n0.2.19 | app新增方法send_help快速发送当前状态的帮助\n0.2.20 | app新增方法on_interval，注册定时任务\n0.2.22 | 修复了send_group_forward_msg无法正确处理消息的bug\n\n\n</details>\n\n# 安装\n`pip install nonebot-plugin-ayaka` \n\n在 `bot.py` 中 写入 `nonebot.load_plugin("ayaka")`\n\n# 快速了解\n\n通过ayaka插件，二次封装nonebot2提供的api，提供专用api，便于其他文字游戏插件的编写\n\n```python\nfrom ayaka import * 包含了\n\n# class \nAyakaBot, AyakaDevice, AyakaApp, Storage, Cache, Trigger, Bot, GroupMessageEvent, MessageEvent, Message, MessageSegment\n\n# function\ncreate_path, create_file, beauty_save\n\n# object\nlogger, ayaka \n```\n\n## ayaka的优势\n\n### 状态机，命令隔离\n\n与nonebot2自带的state相比，ayaka更专注于提供长期的、针对一个群聊整体的、而非仅一个事件处理流程的状态机\n\n而且ayaka能够<b>管理多个不同的文字游戏</b>，他们之间的命令被ayaka在后台隐式地实现隔离，开发者无需担心命令冲突\n\n并且，当同一个文字游戏处于不同的游戏状态时，其命令空间亦是隔离的\n\n### 有限、简练的参数\n\n文字游戏插件所需要的数据高度类似，仅需使用有限、简练的参数即可，无需使用依赖注入，<b>ayaka激进地取消了回调的参数表</b>\n\nayaka将各类参数引用直接放在app身上，节约了开发者反复编写同一份参数表的时间\n\nayaka提供的参数[如下](#上下文切换)\n\n### 缓存、固存\n\n自带[缓存与固存](#缓存与固存)，无需安装额外插件\n\n### 无需关注插件导入顺序，无需使用require\n\n依赖于ayaka的插件，这些插件间如果存在跨插件引用，无需关心插件导入顺序\n\n### 内置插件\n\n- 帮助：只需设置app.help，用户便可通过#help命令获取帮助\n- 状态：随时查看ayaka管理的应用状态\n- 应用管理：管理员可以选择启用/禁用群里的各个文字游戏应用\n\n### 不止于文字游戏\n\n如果其他插件想要利用ayaka实现缓存、固存、状态机管理、命令隔离，只需遵循ayaka插件的编写规范即可使用\n\n\n# 插件编写范例\n\n```python\n\'\'\'\n    具有状态机的复读模块\n\'\'\'\nfrom ayaka import *\n\napp = AyakaApp("echo")\n\n# ayaka内置帮助插件，用户可通过#help命令展示app.help\napp.help = "复读只因"\n\n# 另一种写法\n# 当app处于run状态时，用户发送help指令将返回对应的提示 \napp.help = {\n    "介绍":"复读只因",\n    "run":"echo正在运行~\\n使用[#exit] 退出"\n}\n\n\n@app.on_command("echo")\nasync def app_entrance():\n    # 运行该应用\n    # 令其进入run状态\n    f, info = app.start("run")\n\n    # 用户可以为该复读提供一个前缀，例如 "无穷小亮说："\n    if app.args:\n        app.cache.prefix = app.args[0]\n\n    await app.send(info)\n\n\n# 当app为run状态时响应\n@app.on_command(["exit", "退出"], "run")\nasync def app_exit():\n    # 关闭该应用\n    f, info = app.close()\n    await app.send(info)\n\n\n# 当app为run状态时响应\n@app.on_text("run")\nasync def repeat():\n    prefix = app.cache.prefix\n    if prefix is None:\n        prefix = ""\n    await app.send(prefix + str(app.message))\n\n\n# 桌面模式下执行\n@app.on_text()\nasync def hi():\n    if str(app.message).startswith("hello"):\n        await app.send(app.message)\n```\n\n<img src="./doc/chat.png">\n\n## 注册命令监听\n`@app.on_command(cmds, states=None, super=False)`\n\n指示AyakaApp将一个或多个`命令监听`注册到指定的一个或多个状态下\n\n注意：写入的单项字符串会自动转换为数组，例如 "echo" => ["echo"]，因此当开发者仅需要指定一个命令或状态时，无需多敲一对`[]`\n\n如果states缺省，则默认将该命令注册到[桌面模式](#桌面模式)\n\n## 注册消息监听\n`@app.on_text(states=None, super=False)`\n\n指示AyakaApp将`消息监听`注册到指定的一个或多个状态下\n\n如果states缺省，则默认将该消息监听注册到[桌面模式](#桌面模式)（相当于 [即问即答式应用](#即问即答式应用) 的回调）\n\n# 机器人、设备、应用\n`Ayaka`将为每一个建立了ws连接的`Bot`创建一个对应的`AyakaBot`\n\n每一个`AyakaBot`内部保存了该机器人所管理的所有群聊和私聊，并将它们视为设备`AyakaDevice`进行管理\n\n而依附于`Ayaka`的`文字游戏插件`是安装到各个设备上的应用`AyakaApp`\n\n同一时刻同一设备只能运行一个应用，各个应用的命令相互隔离，同一应用内不同状态时的命令相互隔离\n\n应用分为两类：交互式应用，即问即答式应用\n\n## 交互式应用\n\n- 文字游戏（需要状态机支持，用户的历史输入会影响当前的输出）\n\n桌面模式下，可以运行交互式应用的启动命令，随后ayaka退出桌面模式，进入仅运行该交互式应用的独占模式\n\n## 即问即答式应用\n\n即问即答时应用仅在桌面模式下运行\n\n- 计算器（无状态，用户的历史输入对当前的输出没有任何影响）\n\n不过，开发者在编写插件时，使用统一的`AyakaApp`来声明即可，通过是否声明states即可区分两种应用\n\n# 桌面模式\n如果没有任何应用在运行，则设备进入桌面模式\n\n此时，可以发送命令`开启`交互式应用，可以发送命令`执行`即问即答式应用\n\n开启交互式应用后，设备将只对交互式应用里注册的命令做出响应\n\n不过，为了满足特殊需要，注册command或text时可设置`super=True`，则该回调可以优先于任何交互式应用执行\n\n例如，背包查询插件\n\n```python\n\'\'\'\n    背包\n\'\'\'\nfrom ayaka import *\n\napp = AyakaApp(\'背包\', only_group=True)\napp.help = "[#bag]"\n\n\n@app.on_command([\'bag\', \'背包\'], super=True)\nasync def bag():\n    uid = app.event.user_id\n    name = app.event.sender.card\n    money = get_money(app, uid)\n\n    ans = f"[{name}] 当前有 {money}金"\n    await app.send(ans)\n\n\ndef get_money(_app: AyakaApp, uid: int) -> int:\n    sa = _app.storage.accessor(uid, "money")\n    money = sa.get()\n    if money is None:\n        # 初始100金\n        sa.set(100)\n        return 100\n    return money\n```\n\n无论当前是否有交互式应用运行，都不影响该插件的`bag`回调的命令触发，这样可以便于玩家快速查询背包，而无需中断当前正在进行的游戏\n\n这一特性的具体实现可以查看 `ayaka/core/deal.py:deal_device()`\n\n\n# 上下文切换\n触发回调时，插件里的app会自动切换到对应`机器人`对应`设备`的对应`应用`\n\n所有回调也无需使用参数，所有参数都已经写入到app身上了\n\n可以使用的参数有：\n\n|名称|类型|功能|\n|-|-|-|\n| app.state   | `str`          | 应用当前的状态 |\n| app.valid   | `bool`         | 应用在当前设备 可启用/已禁用 |\n| app.abot    | `AyakaBot`     | 保存了当前机器人的所有设备 |\n| app.bot     | `Bot` | 用于发送各种命令和消息，来自于`nonebot.adapters.onebot.v11` |\n| app.device  | `AyakaDevice`  | 保存了当前设备的所有应用 |\n| app.event   | `MessageEvent` | 当前消息事件 |\n| app.message | `Message`      | 删除了命令后剩下的消息部分，例如 "#exit你好" => "你好" |\n| app.args    | `List[str]`    | `删除了命令后剩下的消息部分` 按照 `shell分割规则` 得到的 `参数列表` |\n| app.cmd     | `str`          | 对于注册了多个命令的回调，告知该回调，本次响应是针对哪个命令 |\n| app.cache   | `Cache`        | 为本应用提供的缓存，使用`app.cache.\\<name>`即可存取数据 |\n| app.storage | `Storage`      | 为本应用提供的本地存取，使用`app.storage.accessor`创建一个访问器，随后`get`、`set`即可，保存地址为 `data/storage/<bot_id>/<device_id>/<app_name>.json` |\n\n得益于上下文机制，发送消息时，如下两种发送方式都是允许的\n\n- `await app.bot.send(app.event, "我在你上面")`\n- `await app.send("你给我下来")`\n\n# 缓存与固存\n使用`app.cache`和`app.storage`实现，各个`机器人`各个`设备`各个`应用`间的存储是相互隔离的\n\n## 缓存读写\n\n```python\n# 通过魔术方法 __setattr__ 实现\n\n...\n\napp.cache.users = users\n\n...\n\nusers = app.cache.users\n\n...\n\n```\n\n## 固存访问器\n\n```python\nsa = app.storage.accessor("father", "name")\nsa.set("周朴园")\nsa = app.storage.accessor("father", "age")\nsa.set(42)\nsa = app.storage.accessor("mother")\nsa.set("周侍萍")\n```\n\n如上代码对应的现实存储为：\n\n打开data/storage/<bot_id>/<device_id>/<app_name>.json文件\n\n```json\n{\n    "father":{\n        "name":"周朴园",\n        "age":42\n    },\n    "mother": "周侍萍"\n}\n```\n\n# 更新计划\n`app.storage`可以考虑修改为sqlite实现，而不再使用本地的json文件\n',
    'author': 'Su',
    'author_email': 'wxlxy316@163.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/bridgeL/nonebot-plugin-ayaka',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
