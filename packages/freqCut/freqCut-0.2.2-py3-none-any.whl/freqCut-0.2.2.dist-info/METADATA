Metadata-Version: 2.1
Name: freqCut
Version: 0.2.2
Summary: 全局最优的等频分组包，通过最小化每组占比与指定占比的残差最小平方和来实现
Home-page: https://github.com/wangwenhao-DATA-OG/freqCut
Author: 王文皓(wangwenhao)
Author-email: DATA-OG@139.com
License: UNKNOWN
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.0
Description-Content-Type: text/markdown
Requires-Dist: DagLpDp (>=0.1.1)

# freqCut
一个等频切割数列的包，通过最小化每组的实际频率与每组期望频率的残差平方和来寻找一个最优的离散组合切割方法
# 安装
pip install freqCut

# 功能
1.支持左闭右开  
2.对比现有包，该包对首尾临界值做了合理的处理。如：1.最后一组为右闭。2：最大值倾斜时的处理。  
3.通过最小化每组的频率与期望频率的残差平方和来寻找一个最优的离散组合切割方法  
4.因为是最优的离散组合切割，所以对偏斜和集中的数据也给出了最合理的切割方法  
5.计算出的切割方法用于另一组数列时，可以按照新的数列自动扩展最大和最小值  
6.支持带有权重的数列

# 示例
```
from freqCut.cutter import freq_cut,cut_by_bins,freq_cut_array
import numpy as np
if __name__=='__main__':
    data1 = [4,2,6,np.nan,2,2,None,3,4,10,3,7,1,1,10,5,4,7,7,8,10,8,8,9,10,10]
    weight = None
    threshold_distr=0.2
    min_distr = 0.1
    
    #计算分段
    bins = freq_cut(data1,threshold_distr,min_distr,weight)
    print('bins:',bins)
    
    #按照分段对数量列进行转换
    data_bin1 = cut_by_bins(data1,bins)
    print('data_bin1:',data_bin1)
    
    #最小值由1变为-1，最大值由10变为11
    data2 = [4,2,11,np.nan,-1,2,None,3,4,10,3,7,1,1,11,5,4,7,7,8,-1,2,8,9,10,10]
    #返回的分组自动扩展了最大和最小值，第一组变为[-1.0,3)，最后一组变为[10,11.0]
    data_bin2 = cut_by_bins(data2,bins)
    print('data_bin2:',data_bin2)
    
    
    #将多个数列进行分组。分段按照cutby来计算
    data_bins = freq_cut_array([data1,data2],threshold_distr,min_distr,cutby=0,weight=weight)
    #对比前后两次的data_bin1，可以看到在freq_cut_array中，即使数列的最大或最小值没有超出cutby数列所产生的分段，但是由于其他数列的最大值或最小值超出分段所对应的最大或最小值，所以该数列也会被自动扩展。这样是为了组内分段统一（对齐）
    print('data_bin1:',data_bins[0])
    print('data_bin2:',data_bins[1])
```

# API
## value_counts_weight(data,weight=None)  
类似pandas中的value_counts，但是支持权重  
data:需要被等频分组的数列.array_like  
weight:data中每个数据的权重，如果权重相等则为None，默认为None。array_like  
return  
data每个取值的占比。pd.Series  

## freq_cut(data,threshold_distr,min_distr,weight=None)  
等频分段  
data:需要被等频分组的数列.array_like  
threshold_distr:当小于1时，每个组期望的占比。当大于1时，分成多少组  
min_distr:由于数据可能偏斜或集中，所以无法严格遵守threshold_distr，此时你所能接受的最小的分组占比  
weight:与data对应的权重。array_like  
return  
bins:分组信息。例如 ['[1,3)', '[3,5)', '[5,8)', '[8,10)', '[10,10]']。list  

## cut_by_bins(data,bins)  
按照指定的bins来对data进行分段  
data:需要被分组的数列.array_like  
bins:分组信息。例如 ['[1,3)', '[3,5)', '[5,8)', '[8,10)', '[10,10]']。注意：一个组内的两个界值仅用逗号分割，不要加空格，必须严格遵守格式。list  
return  
data的每个值所在的分段。pd.Series

## freq_cut_array(datas,threshold_distr,min_distr,cutby=0,weight=None)
将一组数列进行统一的分段，分段的数列由cutby来指定  
datas:需要被等频分组的多个数列。  
threshold_distr:当小于1时，每个组期望的占比。当大于1时，分成多少组  
min_distr:由于数据可能偏斜或集中，所以无法严格遵守threshold_distr，此时你所能接受的最小的分组占比  
cutby:datas被用来计算分段的序号  
weight:与data对应的权重。array_like  
return  
每一个data的每个值所在的分段。[pd.Series,pd.Series,...]  


