// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dragon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dragon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dragon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dragon_2eproto DRAGON_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct DRAGON_API TableStruct_dragon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern DRAGON_API const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dragon_2eproto;
namespace dragon {
class Argument;
class ArgumentDefaultTypeInternal;
DRAGON_API extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class DeviceOption;
class DeviceOptionDefaultTypeInternal;
DRAGON_API extern DeviceOptionDefaultTypeInternal _DeviceOption_default_instance_;
class GraphDef;
class GraphDefDefaultTypeInternal;
DRAGON_API extern GraphDefDefaultTypeInternal _GraphDef_default_instance_;
class OperatorDef;
class OperatorDefDefaultTypeInternal;
DRAGON_API extern OperatorDefDefaultTypeInternal _OperatorDef_default_instance_;
class TensorProto;
class TensorProtoDefaultTypeInternal;
DRAGON_API extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
class TensorProtos;
class TensorProtosDefaultTypeInternal;
DRAGON_API extern TensorProtosDefaultTypeInternal _TensorProtos_default_instance_;
}  // namespace dragon
PROTOBUF_NAMESPACE_OPEN
template<> DRAGON_API ::dragon::Argument* Arena::CreateMaybeMessage<::dragon::Argument>(Arena*);
template<> DRAGON_API ::dragon::DeviceOption* Arena::CreateMaybeMessage<::dragon::DeviceOption>(Arena*);
template<> DRAGON_API ::dragon::GraphDef* Arena::CreateMaybeMessage<::dragon::GraphDef>(Arena*);
template<> DRAGON_API ::dragon::OperatorDef* Arena::CreateMaybeMessage<::dragon::OperatorDef>(Arena*);
template<> DRAGON_API ::dragon::TensorProto* Arena::CreateMaybeMessage<::dragon::TensorProto>(Arena*);
template<> DRAGON_API ::dragon::TensorProtos* Arena::CreateMaybeMessage<::dragon::TensorProtos>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dragon {

enum TensorProto_DataType : int {
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_INT32 = 2,
  TensorProto_DataType_BYTE = 3,
  TensorProto_DataType_STRING = 4,
  TensorProto_DataType_BOOL = 5,
  TensorProto_DataType_UINT8 = 6,
  TensorProto_DataType_INT8 = 7,
  TensorProto_DataType_UINT16 = 8,
  TensorProto_DataType_INT16 = 9,
  TensorProto_DataType_INT64 = 10,
  TensorProto_DataType_FLOAT16 = 12,
  TensorProto_DataType_DOUBLE = 13
};
DRAGON_API bool TensorProto_DataType_IsValid(int value);
constexpr TensorProto_DataType TensorProto_DataType_DataType_MIN = TensorProto_DataType_UNDEFINED;
constexpr TensorProto_DataType TensorProto_DataType_DataType_MAX = TensorProto_DataType_DOUBLE;
constexpr int TensorProto_DataType_DataType_ARRAYSIZE = TensorProto_DataType_DataType_MAX + 1;

DRAGON_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorProto_DataType_descriptor();
template<typename T>
inline const std::string& TensorProto_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TensorProto_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TensorProto_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TensorProto_DataType_descriptor(), enum_t_value);
}
inline bool TensorProto_DataType_Parse(
    const std::string& name, TensorProto_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TensorProto_DataType>(
    TensorProto_DataType_descriptor(), name, value);
}
enum DeviceTypeProto : int {
  PROTO_CPU = 0,
  PROTO_CUDA = 1,
  PROTO_MPS = 2
};
DRAGON_API bool DeviceTypeProto_IsValid(int value);
constexpr DeviceTypeProto DeviceTypeProto_MIN = PROTO_CPU;
constexpr DeviceTypeProto DeviceTypeProto_MAX = PROTO_MPS;
constexpr int DeviceTypeProto_ARRAYSIZE = DeviceTypeProto_MAX + 1;

DRAGON_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceTypeProto_descriptor();
template<typename T>
inline const std::string& DeviceTypeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceTypeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceTypeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceTypeProto_descriptor(), enum_t_value);
}
inline bool DeviceTypeProto_Parse(
    const std::string& name, DeviceTypeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceTypeProto>(
    DeviceTypeProto_descriptor(), name, value);
}
// ===================================================================

class DRAGON_API TensorProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dragon.TensorProto) */ {
 public:
  TensorProto();
  virtual ~TensorProto();

  TensorProto(const TensorProto& from);
  TensorProto(TensorProto&& from) noexcept
    : TensorProto() {
    *this = ::std::move(from);
  }

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProto& operator=(TensorProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProto* internal_default_instance() {
    return reinterpret_cast<const TensorProto*>(
               &_TensorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TensorProto& a, TensorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorProto* New() const final {
    return CreateMaybeMessage<TensorProto>(nullptr);
  }

  TensorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorProto& from);
  void MergeFrom(const TensorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dragon.TensorProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dragon_2eproto);
    return ::descriptor_table_dragon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TensorProto_DataType DataType;
  static constexpr DataType UNDEFINED =
    TensorProto_DataType_UNDEFINED;
  static constexpr DataType FLOAT =
    TensorProto_DataType_FLOAT;
  static constexpr DataType INT32 =
    TensorProto_DataType_INT32;
  static constexpr DataType BYTE =
    TensorProto_DataType_BYTE;
  static constexpr DataType STRING =
    TensorProto_DataType_STRING;
  static constexpr DataType BOOL =
    TensorProto_DataType_BOOL;
  static constexpr DataType UINT8 =
    TensorProto_DataType_UINT8;
  static constexpr DataType INT8 =
    TensorProto_DataType_INT8;
  static constexpr DataType UINT16 =
    TensorProto_DataType_UINT16;
  static constexpr DataType INT16 =
    TensorProto_DataType_INT16;
  static constexpr DataType INT64 =
    TensorProto_DataType_INT64;
  static constexpr DataType FLOAT16 =
    TensorProto_DataType_FLOAT16;
  static constexpr DataType DOUBLE =
    TensorProto_DataType_DOUBLE;
  static inline bool DataType_IsValid(int value) {
    return TensorProto_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    TensorProto_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    TensorProto_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    TensorProto_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return TensorProto_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return TensorProto_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(const std::string& name,
      DataType* value) {
    return TensorProto_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kFloatDataFieldNumber = 3,
    kInt32DataFieldNumber = 4,
    kStringDataFieldNumber = 6,
    kDoubleDataFieldNumber = 9,
    kInt64DataFieldNumber = 10,
    kByteDataFieldNumber = 5,
    kNameFieldNumber = 7,
    kRawDataFieldNumber = 13,
    kDataTypeFieldNumber = 2,
  };
  // repeated int32 dims = 1;
  int dims_size() const;
  void clear_dims();
  ::PROTOBUF_NAMESPACE_ID::int32 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_dims();

  // repeated float float_data = 3 [packed = true];
  int float_data_size() const;
  void clear_float_data();
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      float_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_float_data();

  // repeated int32 int32_data = 4 [packed = true];
  int int32_data_size() const;
  void clear_int32_data();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_data(int index) const;
  void set_int32_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_int32_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      int32_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_int32_data();

  // repeated bytes string_data = 6;
  int string_data_size() const;
  void clear_string_data();
  const std::string& string_data(int index) const;
  std::string* mutable_string_data(int index);
  void set_string_data(int index, const std::string& value);
  void set_string_data(int index, std::string&& value);
  void set_string_data(int index, const char* value);
  void set_string_data(int index, const void* value, size_t size);
  std::string* add_string_data();
  void add_string_data(const std::string& value);
  void add_string_data(std::string&& value);
  void add_string_data(const char* value);
  void add_string_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_data();

  // repeated double double_data = 9 [packed = true];
  int double_data_size() const;
  void clear_double_data();
  double double_data(int index) const;
  void set_double_data(int index, double value);
  void add_double_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      double_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_double_data();

  // repeated int64 int64_data = 10 [packed = true];
  int int64_data_size() const;
  void clear_int64_data();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_data(int index) const;
  void set_int64_data(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_int64_data(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      int64_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_int64_data();

  // optional bytes byte_data = 5;
  bool has_byte_data() const;
  void clear_byte_data();
  const std::string& byte_data() const;
  void set_byte_data(const std::string& value);
  void set_byte_data(std::string&& value);
  void set_byte_data(const char* value);
  void set_byte_data(const void* value, size_t size);
  std::string* mutable_byte_data();
  std::string* release_byte_data();
  void set_allocated_byte_data(std::string* byte_data);

  // optional string name = 7;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional bytes raw_data = 13;
  bool has_raw_data() const;
  void clear_raw_data();
  const std::string& raw_data() const;
  void set_raw_data(const std::string& value);
  void set_raw_data(std::string&& value);
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  std::string* mutable_raw_data();
  std::string* release_raw_data();
  void set_allocated_raw_data(std::string* raw_data);

  // optional .dragon.TensorProto.DataType data_type = 2 [default = FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  ::dragon::TensorProto_DataType data_type() const;
  void set_data_type(::dragon::TensorProto_DataType value);

  // @@protoc_insertion_point(class_scope:dragon.TensorProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > dims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > float_data_;
  mutable std::atomic<int> _float_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > int32_data_;
  mutable std::atomic<int> _int32_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > double_data_;
  mutable std::atomic<int> _double_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > int64_data_;
  mutable std::atomic<int> _int64_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr byte_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
  int data_type_;
  friend struct ::TableStruct_dragon_2eproto;
};
// -------------------------------------------------------------------

class DRAGON_API TensorProtos :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dragon.TensorProtos) */ {
 public:
  TensorProtos();
  virtual ~TensorProtos();

  TensorProtos(const TensorProtos& from);
  TensorProtos(TensorProtos&& from) noexcept
    : TensorProtos() {
    *this = ::std::move(from);
  }

  inline TensorProtos& operator=(const TensorProtos& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProtos& operator=(TensorProtos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorProtos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProtos* internal_default_instance() {
    return reinterpret_cast<const TensorProtos*>(
               &_TensorProtos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TensorProtos& a, TensorProtos& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProtos* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorProtos* New() const final {
    return CreateMaybeMessage<TensorProtos>(nullptr);
  }

  TensorProtos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorProtos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorProtos& from);
  void MergeFrom(const TensorProtos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorProtos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dragon.TensorProtos";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dragon_2eproto);
    return ::descriptor_table_dragon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtosFieldNumber = 1,
  };
  // repeated .dragon.TensorProto protos = 1;
  int protos_size() const;
  void clear_protos();
  ::dragon::TensorProto* mutable_protos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::TensorProto >*
      mutable_protos();
  const ::dragon::TensorProto& protos(int index) const;
  ::dragon::TensorProto* add_protos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::TensorProto >&
      protos() const;

  // @@protoc_insertion_point(class_scope:dragon.TensorProtos)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::TensorProto > protos_;
  friend struct ::TableStruct_dragon_2eproto;
};
// -------------------------------------------------------------------

class DRAGON_API DeviceOption :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dragon.DeviceOption) */ {
 public:
  DeviceOption();
  virtual ~DeviceOption();

  DeviceOption(const DeviceOption& from);
  DeviceOption(DeviceOption&& from) noexcept
    : DeviceOption() {
    *this = ::std::move(from);
  }

  inline DeviceOption& operator=(const DeviceOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceOption& operator=(DeviceOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceOption* internal_default_instance() {
    return reinterpret_cast<const DeviceOption*>(
               &_DeviceOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeviceOption& a, DeviceOption& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceOption* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceOption* New() const final {
    return CreateMaybeMessage<DeviceOption>(nullptr);
  }

  DeviceOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceOption& from);
  void MergeFrom(const DeviceOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dragon.DeviceOption";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dragon_2eproto);
    return ::descriptor_table_dragon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceTypeFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kRandomSeedFieldNumber = 3,
  };
  // optional .dragon.DeviceTypeProto device_type = 1 [default = PROTO_CPU];
  bool has_device_type() const;
  void clear_device_type();
  ::dragon::DeviceTypeProto device_type() const;
  void set_device_type(::dragon::DeviceTypeProto value);

  // optional int32 device_id = 2 [default = 0];
  bool has_device_id() const;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::int32 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 random_seed = 3 [default = 3];
  bool has_random_seed() const;
  void clear_random_seed();
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed() const;
  void set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:dragon.DeviceOption)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int device_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed_;
  friend struct ::TableStruct_dragon_2eproto;
};
// -------------------------------------------------------------------

class DRAGON_API Argument :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dragon.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Argument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const final {
    return CreateMaybeMessage<Argument>(nullptr);
  }

  Argument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dragon.Argument";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dragon_2eproto);
    return ::descriptor_table_dragon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatsFieldNumber = 7,
    kIntsFieldNumber = 8,
    kStringsFieldNumber = 9,
    kNameFieldNumber = 1,
    kSFieldNumber = 4,
    kIFieldNumber = 3,
    kFFieldNumber = 2,
  };
  // repeated float floats = 7;
  int floats_size() const;
  void clear_floats();
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      floats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_floats();

  // repeated int64 ints = 8;
  int ints_size() const;
  void clear_ints();
  ::PROTOBUF_NAMESPACE_ID::int64 ints(int index) const;
  void set_ints(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_ints(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      ints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_ints();

  // repeated bytes strings = 9;
  int strings_size() const;
  void clear_strings();
  const std::string& strings(int index) const;
  std::string* mutable_strings(int index);
  void set_strings(int index, const std::string& value);
  void set_strings(int index, std::string&& value);
  void set_strings(int index, const char* value);
  void set_strings(int index, const void* value, size_t size);
  std::string* add_strings();
  void add_strings(const std::string& value);
  void add_strings(std::string&& value);
  void add_strings(const char* value);
  void add_strings(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& strings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_strings();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional bytes s = 4;
  bool has_s() const;
  void clear_s();
  const std::string& s() const;
  void set_s(const std::string& value);
  void set_s(std::string&& value);
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  std::string* mutable_s();
  std::string* release_s();
  void set_allocated_s(std::string* s);

  // optional int64 i = 3;
  bool has_i() const;
  void clear_i();
  ::PROTOBUF_NAMESPACE_ID::int64 i() const;
  void set_i(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional float f = 2;
  bool has_f() const;
  void clear_f();
  float f() const;
  void set_f(float value);

  // @@protoc_insertion_point(class_scope:dragon.Argument)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > floats_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > ints_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> strings_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::int64 i_;
  float f_;
  friend struct ::TableStruct_dragon_2eproto;
};
// -------------------------------------------------------------------

class DRAGON_API OperatorDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dragon.OperatorDef) */ {
 public:
  OperatorDef();
  virtual ~OperatorDef();

  OperatorDef(const OperatorDef& from);
  OperatorDef(OperatorDef&& from) noexcept
    : OperatorDef() {
    *this = ::std::move(from);
  }

  inline OperatorDef& operator=(const OperatorDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatorDef& operator=(OperatorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperatorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatorDef* internal_default_instance() {
    return reinterpret_cast<const OperatorDef*>(
               &_OperatorDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OperatorDef& a, OperatorDef& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatorDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperatorDef* New() const final {
    return CreateMaybeMessage<OperatorDef>(nullptr);
  }

  OperatorDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperatorDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperatorDef& from);
  void MergeFrom(const OperatorDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dragon.OperatorDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dragon_2eproto);
    return ::descriptor_table_dragon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
    kArgFieldNumber = 5,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 4,
    kDeviceOptionFieldNumber = 6,
  };
  // repeated string input = 1;
  int input_size() const;
  void clear_input();
  const std::string& input(int index) const;
  std::string* mutable_input(int index);
  void set_input(int index, const std::string& value);
  void set_input(int index, std::string&& value);
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  std::string* add_input();
  void add_input(const std::string& value);
  void add_input(std::string&& value);
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input();

  // repeated string output = 2;
  int output_size() const;
  void clear_output();
  const std::string& output(int index) const;
  std::string* mutable_output(int index);
  void set_output(int index, const std::string& value);
  void set_output(int index, std::string&& value);
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  std::string* add_output();
  void add_output(const std::string& value);
  void add_output(std::string&& value);
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output();

  // repeated .dragon.Argument arg = 5;
  int arg_size() const;
  void clear_arg();
  ::dragon::Argument* mutable_arg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >*
      mutable_arg();
  const ::dragon::Argument& arg(int index) const;
  ::dragon::Argument* add_arg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >&
      arg() const;

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // optional .dragon.DeviceOption device_option = 6;
  bool has_device_option() const;
  void clear_device_option();
  const ::dragon::DeviceOption& device_option() const;
  ::dragon::DeviceOption* release_device_option();
  ::dragon::DeviceOption* mutable_device_option();
  void set_allocated_device_option(::dragon::DeviceOption* device_option);

  // @@protoc_insertion_point(class_scope:dragon.OperatorDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument > arg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::dragon::DeviceOption* device_option_;
  friend struct ::TableStruct_dragon_2eproto;
};
// -------------------------------------------------------------------

class DRAGON_API GraphDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dragon.GraphDef) */ {
 public:
  GraphDef();
  virtual ~GraphDef();

  GraphDef(const GraphDef& from);
  GraphDef(GraphDef&& from) noexcept
    : GraphDef() {
    *this = ::std::move(from);
  }

  inline GraphDef& operator=(const GraphDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphDef& operator=(GraphDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GraphDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphDef* internal_default_instance() {
    return reinterpret_cast<const GraphDef*>(
               &_GraphDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GraphDef& a, GraphDef& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GraphDef* New() const final {
    return CreateMaybeMessage<GraphDef>(nullptr);
  }

  GraphDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GraphDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GraphDef& from);
  void MergeFrom(const GraphDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dragon.GraphDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dragon_2eproto);
    return ::descriptor_table_dragon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kInputFieldNumber = 4,
    kOutputFieldNumber = 5,
    kArgFieldNumber = 6,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDeviceOptionFieldNumber = 7,
  };
  // repeated .dragon.OperatorDef op = 1;
  int op_size() const;
  void clear_op();
  ::dragon::OperatorDef* mutable_op(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::OperatorDef >*
      mutable_op();
  const ::dragon::OperatorDef& op(int index) const;
  ::dragon::OperatorDef* add_op();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::OperatorDef >&
      op() const;

  // repeated string input = 4;
  int input_size() const;
  void clear_input();
  const std::string& input(int index) const;
  std::string* mutable_input(int index);
  void set_input(int index, const std::string& value);
  void set_input(int index, std::string&& value);
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  std::string* add_input();
  void add_input(const std::string& value);
  void add_input(std::string&& value);
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input();

  // repeated string output = 5;
  int output_size() const;
  void clear_output();
  const std::string& output(int index) const;
  std::string* mutable_output(int index);
  void set_output(int index, const std::string& value);
  void set_output(int index, std::string&& value);
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  std::string* add_output();
  void add_output(const std::string& value);
  void add_output(std::string&& value);
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output();

  // repeated .dragon.Argument arg = 6;
  int arg_size() const;
  void clear_arg();
  ::dragon::Argument* mutable_arg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >*
      mutable_arg();
  const ::dragon::Argument& arg(int index) const;
  ::dragon::Argument* add_arg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >&
      arg() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string type = 3;
  bool has_type() const;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // optional .dragon.DeviceOption device_option = 7;
  bool has_device_option() const;
  void clear_device_option();
  const ::dragon::DeviceOption& device_option() const;
  ::dragon::DeviceOption* release_device_option();
  ::dragon::DeviceOption* mutable_device_option();
  void set_allocated_device_option(::dragon::DeviceOption* device_option);

  // @@protoc_insertion_point(class_scope:dragon.GraphDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::OperatorDef > op_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument > arg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::dragon::DeviceOption* device_option_;
  friend struct ::TableStruct_dragon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TensorProto

// repeated int32 dims = 1;
inline int TensorProto::dims_size() const {
  return dims_.size();
}
inline void TensorProto::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.dims)
  return dims_.Get(index);
}
inline void TensorProto::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.dims)
}
inline void TensorProto::add_dims(::PROTOBUF_NAMESPACE_ID::int32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.TensorProto.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TensorProto::dims() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProto.dims)
  return dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TensorProto::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProto.dims)
  return &dims_;
}

// optional .dragon.TensorProto.DataType data_type = 2 [default = FLOAT];
inline bool TensorProto::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TensorProto::clear_data_type() {
  data_type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::dragon::TensorProto_DataType TensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.data_type)
  return static_cast< ::dragon::TensorProto_DataType >(data_type_);
}
inline void TensorProto::set_data_type(::dragon::TensorProto_DataType value) {
  assert(::dragon::TensorProto_DataType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  data_type_ = value;
  // @@protoc_insertion_point(field_set:dragon.TensorProto.data_type)
}

// repeated float float_data = 3 [packed = true];
inline int TensorProto::float_data_size() const {
  return float_data_.size();
}
inline void TensorProto::clear_float_data() {
  float_data_.Clear();
}
inline float TensorProto::float_data(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.float_data)
  return float_data_.Get(index);
}
inline void TensorProto::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.float_data)
}
inline void TensorProto::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.TensorProto.float_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorProto::float_data() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProto.float_data)
  return float_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorProto::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProto.float_data)
  return &float_data_;
}

// repeated int32 int32_data = 4 [packed = true];
inline int TensorProto::int32_data_size() const {
  return int32_data_.size();
}
inline void TensorProto::clear_int32_data() {
  int32_data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TensorProto::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.int32_data)
  return int32_data_.Get(index);
}
inline void TensorProto::set_int32_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.int32_data)
}
inline void TensorProto::add_int32_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_data_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.TensorProto.int32_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TensorProto::int32_data() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProto.int32_data)
  return int32_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TensorProto::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProto.int32_data)
  return &int32_data_;
}

// optional bytes byte_data = 5;
inline bool TensorProto::has_byte_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TensorProto::clear_byte_data() {
  byte_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorProto::byte_data() const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.byte_data)
  return byte_data_.GetNoArena();
}
inline void TensorProto::set_byte_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.TensorProto.byte_data)
}
inline std::string* TensorProto::mutable_byte_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dragon.TensorProto.byte_data)
  return byte_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TensorProto::release_byte_data() {
  // @@protoc_insertion_point(field_release:dragon.TensorProto.byte_data)
  if (!has_byte_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return byte_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_byte_data(std::string* byte_data) {
  if (byte_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  byte_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), byte_data);
  // @@protoc_insertion_point(field_set_allocated:dragon.TensorProto.byte_data)
}

// repeated bytes string_data = 6;
inline int TensorProto::string_data_size() const {
  return string_data_.size();
}
inline void TensorProto::clear_string_data() {
  string_data_.Clear();
}
inline const std::string& TensorProto::string_data(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.string_data)
  return string_data_.Get(index);
}
inline std::string* TensorProto::mutable_string_data(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.TensorProto.string_data)
  return string_data_.Mutable(index);
}
inline void TensorProto::set_string_data(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dragon.TensorProto.string_data)
  string_data_.Mutable(index)->assign(value);
}
inline void TensorProto::set_string_data(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dragon.TensorProto.string_data)
  string_data_.Mutable(index)->assign(std::move(value));
}
inline void TensorProto::set_string_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  string_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dragon.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, const void* value, size_t size) {
  string_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dragon.TensorProto.string_data)
}
inline std::string* TensorProto::add_string_data() {
  // @@protoc_insertion_point(field_add_mutable:dragon.TensorProto.string_data)
  return string_data_.Add();
}
inline void TensorProto::add_string_data(const std::string& value) {
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dragon.TensorProto.string_data)
}
inline void TensorProto::add_string_data(std::string&& value) {
  string_data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dragon.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dragon.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const void* value, size_t size) {
  string_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dragon.TensorProto.string_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TensorProto::string_data() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProto.string_data)
  return string_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TensorProto::mutable_string_data() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProto.string_data)
  return &string_data_;
}

// repeated double double_data = 9 [packed = true];
inline int TensorProto::double_data_size() const {
  return double_data_.size();
}
inline void TensorProto::clear_double_data() {
  double_data_.Clear();
}
inline double TensorProto::double_data(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.double_data)
  return double_data_.Get(index);
}
inline void TensorProto::set_double_data(int index, double value) {
  double_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.double_data)
}
inline void TensorProto::add_double_data(double value) {
  double_data_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.TensorProto.double_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TensorProto::double_data() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProto.double_data)
  return double_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TensorProto::mutable_double_data() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProto.double_data)
  return &double_data_;
}

// repeated int64 int64_data = 10 [packed = true];
inline int TensorProto::int64_data_size() const {
  return int64_data_.size();
}
inline void TensorProto::clear_int64_data() {
  int64_data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto::int64_data(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.int64_data)
  return int64_data_.Get(index);
}
inline void TensorProto::set_int64_data(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.int64_data)
}
inline void TensorProto::add_int64_data(::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_data_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.TensorProto.int64_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorProto::int64_data() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProto.int64_data)
  return int64_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorProto::mutable_int64_data() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProto.int64_data)
  return &int64_data_;
}

// optional bytes raw_data = 13;
inline bool TensorProto::has_raw_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TensorProto::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TensorProto::raw_data() const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.raw_data)
  return raw_data_.GetNoArena();
}
inline void TensorProto::set_raw_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.raw_data)
}
inline void TensorProto::set_raw_data(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.TensorProto.raw_data)
}
inline void TensorProto::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.TensorProto.raw_data)
}
inline void TensorProto::set_raw_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.TensorProto.raw_data)
}
inline std::string* TensorProto::mutable_raw_data() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:dragon.TensorProto.raw_data)
  return raw_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TensorProto::release_raw_data() {
  // @@protoc_insertion_point(field_release:dragon.TensorProto.raw_data)
  if (!has_raw_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return raw_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_raw_data(std::string* raw_data) {
  if (raw_data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  raw_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:dragon.TensorProto.raw_data)
}

// optional string name = 7;
inline bool TensorProto::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TensorProto::name() const {
  // @@protoc_insertion_point(field_get:dragon.TensorProto.name)
  return name_.GetNoArena();
}
inline void TensorProto::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.TensorProto.name)
}
inline void TensorProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.TensorProto.name)
}
inline void TensorProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.TensorProto.name)
}
inline void TensorProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.TensorProto.name)
}
inline std::string* TensorProto::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:dragon.TensorProto.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TensorProto::release_name() {
  // @@protoc_insertion_point(field_release:dragon.TensorProto.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dragon.TensorProto.name)
}

// -------------------------------------------------------------------

// TensorProtos

// repeated .dragon.TensorProto protos = 1;
inline int TensorProtos::protos_size() const {
  return protos_.size();
}
inline void TensorProtos::clear_protos() {
  protos_.Clear();
}
inline ::dragon::TensorProto* TensorProtos::mutable_protos(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.TensorProtos.protos)
  return protos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::TensorProto >*
TensorProtos::mutable_protos() {
  // @@protoc_insertion_point(field_mutable_list:dragon.TensorProtos.protos)
  return &protos_;
}
inline const ::dragon::TensorProto& TensorProtos::protos(int index) const {
  // @@protoc_insertion_point(field_get:dragon.TensorProtos.protos)
  return protos_.Get(index);
}
inline ::dragon::TensorProto* TensorProtos::add_protos() {
  // @@protoc_insertion_point(field_add:dragon.TensorProtos.protos)
  return protos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::TensorProto >&
TensorProtos::protos() const {
  // @@protoc_insertion_point(field_list:dragon.TensorProtos.protos)
  return protos_;
}

// -------------------------------------------------------------------

// DeviceOption

// optional .dragon.DeviceTypeProto device_type = 1 [default = PROTO_CPU];
inline bool DeviceOption::has_device_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceOption::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::dragon::DeviceTypeProto DeviceOption::device_type() const {
  // @@protoc_insertion_point(field_get:dragon.DeviceOption.device_type)
  return static_cast< ::dragon::DeviceTypeProto >(device_type_);
}
inline void DeviceOption::set_device_type(::dragon::DeviceTypeProto value) {
  assert(::dragon::DeviceTypeProto_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  device_type_ = value;
  // @@protoc_insertion_point(field_set:dragon.DeviceOption.device_type)
}

// optional int32 device_id = 2 [default = 0];
inline bool DeviceOption::has_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceOption::clear_device_id() {
  device_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::device_id() const {
  // @@protoc_insertion_point(field_get:dragon.DeviceOption.device_id)
  return device_id_;
}
inline void DeviceOption::set_device_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  device_id_ = value;
  // @@protoc_insertion_point(field_set:dragon.DeviceOption.device_id)
}

// optional uint32 random_seed = 3 [default = 3];
inline bool DeviceOption::has_random_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceOption::clear_random_seed() {
  random_seed_ = 3u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceOption::random_seed() const {
  // @@protoc_insertion_point(field_get:dragon.DeviceOption.random_seed)
  return random_seed_;
}
inline void DeviceOption::set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:dragon.DeviceOption.random_seed)
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:dragon.Argument.name)
  return name_.GetNoArena();
}
inline void Argument::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.Argument.name)
}
inline void Argument::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.Argument.name)
}
inline void Argument::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.Argument.name)
}
inline std::string* Argument::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dragon.Argument.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:dragon.Argument.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dragon.Argument.name)
}

// optional float f = 2;
inline bool Argument::has_f() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::clear_f() {
  f_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Argument::f() const {
  // @@protoc_insertion_point(field_get:dragon.Argument.f)
  return f_;
}
inline void Argument::set_f(float value) {
  _has_bits_[0] |= 0x00000008u;
  f_ = value;
  // @@protoc_insertion_point(field_set:dragon.Argument.f)
}

// optional int64 i = 3;
inline bool Argument::has_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::clear_i() {
  i_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Argument::i() const {
  // @@protoc_insertion_point(field_get:dragon.Argument.i)
  return i_;
}
inline void Argument::set_i(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  i_ = value;
  // @@protoc_insertion_point(field_set:dragon.Argument.i)
}

// optional bytes s = 4;
inline bool Argument::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::clear_s() {
  s_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:dragon.Argument.s)
  return s_.GetNoArena();
}
inline void Argument::set_s(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.Argument.s)
}
inline void Argument::set_s(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.Argument.s)
}
inline void Argument::set_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.Argument.s)
}
inline void Argument::set_s(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.Argument.s)
}
inline std::string* Argument::mutable_s() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:dragon.Argument.s)
  return s_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Argument::release_s() {
  // @@protoc_insertion_point(field_release:dragon.Argument.s)
  if (!has_s()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return s_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  s_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:dragon.Argument.s)
}

// repeated float floats = 7;
inline int Argument::floats_size() const {
  return floats_.size();
}
inline void Argument::clear_floats() {
  floats_.Clear();
}
inline float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:dragon.Argument.floats)
  return floats_.Get(index);
}
inline void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.Argument.floats)
}
inline void Argument::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.Argument.floats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:dragon.Argument.floats)
  return floats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:dragon.Argument.floats)
  return &floats_;
}

// repeated int64 ints = 8;
inline int Argument::ints_size() const {
  return ints_.size();
}
inline void Argument::clear_ints() {
  ints_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:dragon.Argument.ints)
  return ints_.Get(index);
}
inline void Argument::set_ints(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:dragon.Argument.ints)
}
inline void Argument::add_ints(::PROTOBUF_NAMESPACE_ID::int64 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:dragon.Argument.ints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:dragon.Argument.ints)
  return ints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:dragon.Argument.ints)
  return &ints_;
}

// repeated bytes strings = 9;
inline int Argument::strings_size() const {
  return strings_.size();
}
inline void Argument::clear_strings() {
  strings_.Clear();
}
inline const std::string& Argument::strings(int index) const {
  // @@protoc_insertion_point(field_get:dragon.Argument.strings)
  return strings_.Get(index);
}
inline std::string* Argument::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.Argument.strings)
  return strings_.Mutable(index);
}
inline void Argument::set_strings(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dragon.Argument.strings)
  strings_.Mutable(index)->assign(value);
}
inline void Argument::set_strings(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dragon.Argument.strings)
  strings_.Mutable(index)->assign(std::move(value));
}
inline void Argument::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dragon.Argument.strings)
}
inline void Argument::set_strings(int index, const void* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dragon.Argument.strings)
}
inline std::string* Argument::add_strings() {
  // @@protoc_insertion_point(field_add_mutable:dragon.Argument.strings)
  return strings_.Add();
}
inline void Argument::add_strings(const std::string& value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dragon.Argument.strings)
}
inline void Argument::add_strings(std::string&& value) {
  strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dragon.Argument.strings)
}
inline void Argument::add_strings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dragon.Argument.strings)
}
inline void Argument::add_strings(const void* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dragon.Argument.strings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Argument::strings() const {
  // @@protoc_insertion_point(field_list:dragon.Argument.strings)
  return strings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Argument::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:dragon.Argument.strings)
  return &strings_;
}

// -------------------------------------------------------------------

// OperatorDef

// repeated string input = 1;
inline int OperatorDef::input_size() const {
  return input_.size();
}
inline void OperatorDef::clear_input() {
  input_.Clear();
}
inline const std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:dragon.OperatorDef.input)
  return input_.Get(index);
}
inline std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.OperatorDef.input)
  return input_.Mutable(index);
}
inline void OperatorDef::set_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dragon.OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dragon.OperatorDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
inline void OperatorDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dragon.OperatorDef.input)
}
inline void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dragon.OperatorDef.input)
}
inline std::string* OperatorDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:dragon.OperatorDef.input)
  return input_.Add();
}
inline void OperatorDef::add_input(const std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dragon.OperatorDef.input)
}
inline void OperatorDef::add_input(std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dragon.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dragon.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dragon.OperatorDef.input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:dragon.OperatorDef.input)
  return input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:dragon.OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
inline int OperatorDef::output_size() const {
  return output_.size();
}
inline void OperatorDef::clear_output() {
  output_.Clear();
}
inline const std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:dragon.OperatorDef.output)
  return output_.Get(index);
}
inline std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.OperatorDef.output)
  return output_.Mutable(index);
}
inline void OperatorDef::set_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dragon.OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dragon.OperatorDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
inline void OperatorDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dragon.OperatorDef.output)
}
inline void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dragon.OperatorDef.output)
}
inline std::string* OperatorDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:dragon.OperatorDef.output)
  return output_.Add();
}
inline void OperatorDef::add_output(const std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dragon.OperatorDef.output)
}
inline void OperatorDef::add_output(std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dragon.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dragon.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dragon.OperatorDef.output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:dragon.OperatorDef.output)
  return output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:dragon.OperatorDef.output)
  return &output_;
}

// optional string name = 3;
inline bool OperatorDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperatorDef::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:dragon.OperatorDef.name)
  return name_.GetNoArena();
}
inline void OperatorDef::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.OperatorDef.name)
}
inline void OperatorDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.OperatorDef.name)
}
inline std::string* OperatorDef::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dragon.OperatorDef.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_name() {
  // @@protoc_insertion_point(field_release:dragon.OperatorDef.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dragon.OperatorDef.name)
}

// optional string type = 4;
inline bool OperatorDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperatorDef::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:dragon.OperatorDef.type)
  return type_.GetNoArena();
}
inline void OperatorDef::set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.OperatorDef.type)
}
inline void OperatorDef::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.OperatorDef.type)
}
inline std::string* OperatorDef::mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:dragon.OperatorDef.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_type() {
  // @@protoc_insertion_point(field_release:dragon.OperatorDef.type)
  if (!has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:dragon.OperatorDef.type)
}

// repeated .dragon.Argument arg = 5;
inline int OperatorDef::arg_size() const {
  return arg_.size();
}
inline void OperatorDef::clear_arg() {
  arg_.Clear();
}
inline ::dragon::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.OperatorDef.arg)
  return arg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:dragon.OperatorDef.arg)
  return &arg_;
}
inline const ::dragon::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:dragon.OperatorDef.arg)
  return arg_.Get(index);
}
inline ::dragon::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:dragon.OperatorDef.arg)
  return arg_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:dragon.OperatorDef.arg)
  return arg_;
}

// optional .dragon.DeviceOption device_option = 6;
inline bool OperatorDef::has_device_option() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperatorDef::clear_device_option() {
  if (device_option_ != nullptr) device_option_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::dragon::DeviceOption& OperatorDef::device_option() const {
  const ::dragon::DeviceOption* p = device_option_;
  // @@protoc_insertion_point(field_get:dragon.OperatorDef.device_option)
  return p != nullptr ? *p : *reinterpret_cast<const ::dragon::DeviceOption*>(
      &::dragon::_DeviceOption_default_instance_);
}
inline ::dragon::DeviceOption* OperatorDef::release_device_option() {
  // @@protoc_insertion_point(field_release:dragon.OperatorDef.device_option)
  _has_bits_[0] &= ~0x00000004u;
  ::dragon::DeviceOption* temp = device_option_;
  device_option_ = nullptr;
  return temp;
}
inline ::dragon::DeviceOption* OperatorDef::mutable_device_option() {
  _has_bits_[0] |= 0x00000004u;
  if (device_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::dragon::DeviceOption>(GetArenaNoVirtual());
    device_option_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dragon.OperatorDef.device_option)
  return device_option_;
}
inline void OperatorDef::set_allocated_device_option(::dragon::DeviceOption* device_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_option_;
  }
  if (device_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_option, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_option_ = device_option;
  // @@protoc_insertion_point(field_set_allocated:dragon.OperatorDef.device_option)
}

// -------------------------------------------------------------------

// GraphDef

// repeated .dragon.OperatorDef op = 1;
inline int GraphDef::op_size() const {
  return op_.size();
}
inline void GraphDef::clear_op() {
  op_.Clear();
}
inline ::dragon::OperatorDef* GraphDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.op)
  return op_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::OperatorDef >*
GraphDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:dragon.GraphDef.op)
  return &op_;
}
inline const ::dragon::OperatorDef& GraphDef::op(int index) const {
  // @@protoc_insertion_point(field_get:dragon.GraphDef.op)
  return op_.Get(index);
}
inline ::dragon::OperatorDef* GraphDef::add_op() {
  // @@protoc_insertion_point(field_add:dragon.GraphDef.op)
  return op_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::OperatorDef >&
GraphDef::op() const {
  // @@protoc_insertion_point(field_list:dragon.GraphDef.op)
  return op_;
}

// optional string name = 2;
inline bool GraphDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GraphDef::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GraphDef::name() const {
  // @@protoc_insertion_point(field_get:dragon.GraphDef.name)
  return name_.GetNoArena();
}
inline void GraphDef::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.GraphDef.name)
}
inline void GraphDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.GraphDef.name)
}
inline void GraphDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.GraphDef.name)
}
inline void GraphDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.GraphDef.name)
}
inline std::string* GraphDef::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GraphDef::release_name() {
  // @@protoc_insertion_point(field_release:dragon.GraphDef.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GraphDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dragon.GraphDef.name)
}

// optional string type = 3;
inline bool GraphDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GraphDef::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GraphDef::type() const {
  // @@protoc_insertion_point(field_get:dragon.GraphDef.type)
  return type_.GetNoArena();
}
inline void GraphDef::set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dragon.GraphDef.type)
}
inline void GraphDef::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dragon.GraphDef.type)
}
inline void GraphDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dragon.GraphDef.type)
}
inline void GraphDef::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dragon.GraphDef.type)
}
inline std::string* GraphDef::mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GraphDef::release_type() {
  // @@protoc_insertion_point(field_release:dragon.GraphDef.type)
  if (!has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GraphDef::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:dragon.GraphDef.type)
}

// repeated string input = 4;
inline int GraphDef::input_size() const {
  return input_.size();
}
inline void GraphDef::clear_input() {
  input_.Clear();
}
inline const std::string& GraphDef::input(int index) const {
  // @@protoc_insertion_point(field_get:dragon.GraphDef.input)
  return input_.Get(index);
}
inline std::string* GraphDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.input)
  return input_.Mutable(index);
}
inline void GraphDef::set_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dragon.GraphDef.input)
  input_.Mutable(index)->assign(value);
}
inline void GraphDef::set_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dragon.GraphDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
inline void GraphDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dragon.GraphDef.input)
}
inline void GraphDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dragon.GraphDef.input)
}
inline std::string* GraphDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:dragon.GraphDef.input)
  return input_.Add();
}
inline void GraphDef::add_input(const std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dragon.GraphDef.input)
}
inline void GraphDef::add_input(std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dragon.GraphDef.input)
}
inline void GraphDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dragon.GraphDef.input)
}
inline void GraphDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dragon.GraphDef.input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GraphDef::input() const {
  // @@protoc_insertion_point(field_list:dragon.GraphDef.input)
  return input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GraphDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:dragon.GraphDef.input)
  return &input_;
}

// repeated string output = 5;
inline int GraphDef::output_size() const {
  return output_.size();
}
inline void GraphDef::clear_output() {
  output_.Clear();
}
inline const std::string& GraphDef::output(int index) const {
  // @@protoc_insertion_point(field_get:dragon.GraphDef.output)
  return output_.Get(index);
}
inline std::string* GraphDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.output)
  return output_.Mutable(index);
}
inline void GraphDef::set_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dragon.GraphDef.output)
  output_.Mutable(index)->assign(value);
}
inline void GraphDef::set_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dragon.GraphDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
inline void GraphDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dragon.GraphDef.output)
}
inline void GraphDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dragon.GraphDef.output)
}
inline std::string* GraphDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:dragon.GraphDef.output)
  return output_.Add();
}
inline void GraphDef::add_output(const std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dragon.GraphDef.output)
}
inline void GraphDef::add_output(std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dragon.GraphDef.output)
}
inline void GraphDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dragon.GraphDef.output)
}
inline void GraphDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dragon.GraphDef.output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GraphDef::output() const {
  // @@protoc_insertion_point(field_list:dragon.GraphDef.output)
  return output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GraphDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:dragon.GraphDef.output)
  return &output_;
}

// repeated .dragon.Argument arg = 6;
inline int GraphDef::arg_size() const {
  return arg_.size();
}
inline void GraphDef::clear_arg() {
  arg_.Clear();
}
inline ::dragon::Argument* GraphDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.arg)
  return arg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >*
GraphDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:dragon.GraphDef.arg)
  return &arg_;
}
inline const ::dragon::Argument& GraphDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:dragon.GraphDef.arg)
  return arg_.Get(index);
}
inline ::dragon::Argument* GraphDef::add_arg() {
  // @@protoc_insertion_point(field_add:dragon.GraphDef.arg)
  return arg_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dragon::Argument >&
GraphDef::arg() const {
  // @@protoc_insertion_point(field_list:dragon.GraphDef.arg)
  return arg_;
}

// optional .dragon.DeviceOption device_option = 7;
inline bool GraphDef::has_device_option() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GraphDef::clear_device_option() {
  if (device_option_ != nullptr) device_option_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::dragon::DeviceOption& GraphDef::device_option() const {
  const ::dragon::DeviceOption* p = device_option_;
  // @@protoc_insertion_point(field_get:dragon.GraphDef.device_option)
  return p != nullptr ? *p : *reinterpret_cast<const ::dragon::DeviceOption*>(
      &::dragon::_DeviceOption_default_instance_);
}
inline ::dragon::DeviceOption* GraphDef::release_device_option() {
  // @@protoc_insertion_point(field_release:dragon.GraphDef.device_option)
  _has_bits_[0] &= ~0x00000004u;
  ::dragon::DeviceOption* temp = device_option_;
  device_option_ = nullptr;
  return temp;
}
inline ::dragon::DeviceOption* GraphDef::mutable_device_option() {
  _has_bits_[0] |= 0x00000004u;
  if (device_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::dragon::DeviceOption>(GetArenaNoVirtual());
    device_option_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dragon.GraphDef.device_option)
  return device_option_;
}
inline void GraphDef::set_allocated_device_option(::dragon::DeviceOption* device_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_option_;
  }
  if (device_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_option, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_option_ = device_option;
  // @@protoc_insertion_point(field_set_allocated:dragon.GraphDef.device_option)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dragon

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dragon::TensorProto_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dragon::TensorProto_DataType>() {
  return ::dragon::TensorProto_DataType_descriptor();
}
template <> struct is_proto_enum< ::dragon::DeviceTypeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dragon::DeviceTypeProto>() {
  return ::dragon::DeviceTypeProto_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dragon_2eproto
