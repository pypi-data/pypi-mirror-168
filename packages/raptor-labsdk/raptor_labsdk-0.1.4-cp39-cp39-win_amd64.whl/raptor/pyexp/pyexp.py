
# python wrapper for package github.com/raptor-ml/raptor/pkg/pyexp within overall package pyexp
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy gen --name pyexp --output D:\a\raptor\raptor\labsdk\raptor\pyexp --no-make --vm C:\Users\runneradmin\AppData\Local\Temp\cibw-run-9nzsno_f\cp39-win_amd64\build\venv\Scripts\python.exe github.com/raptor-ml/raptor/pkg/pyexp

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _pyexp
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from pyexp import pyexp
# and then refer to everything using pyexp. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []pyexp.Instruction
class Slice_pyexp_Instruction(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.Slice_pyexp_Instruction_CTor()
			_pyexp.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pyexp_Instruction.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		s = 'pyexp.Slice_pyexp_Instruction len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'pyexp.Slice_pyexp_Instruction([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pyexp.Slice_pyexp_Instruction_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pyexp.Slice_pyexp_Instruction_len(self.handle)
				return Slice_pyexp_Instruction(handle=_pyexp.Slice_pyexp_Instruction_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Instruction(handle=_pyexp.Slice_pyexp_Instruction_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pyexp.Slice_pyexp_Instruction_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pyexp_Instruction.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pyexp.Slice_pyexp_Instruction_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pyexp.Slice_pyexp_Instruction_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []interface{}
class Slice_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.Slice_interface__CTor()
			_pyexp.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_interface_.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		s = 'pyexp.Slice_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'pyexp.Slice_interface_([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pyexp.Slice_interface__len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pyexp.Slice_interface__len(self.handle)
				return Slice_interface_(handle=_pyexp.Slice_interface__subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _pyexp.Slice_interface__elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pyexp.Slice_interface__set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_interface_.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pyexp.Slice_interface__elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pyexp.Slice_interface__append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.Map_string_Slice_string_CTor()
			_pyexp.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_pyexp.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		s = 'pyexp.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'pyexp.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _pyexp.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_pyexp.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_pyexp.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _pyexp.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_pyexp.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _pyexp.Map_string_Slice_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class InstructionOp(Enum):
	InstructionOpNone = 0
	InstructionOpSet = 1
	InstructionOpAppend = 2
	InstructionOpIncr = 3
	InstructionOpUpdate = 4

InstructionOpNone = 0
InstructionOpSet = 1
InstructionOpAppend = 2
InstructionOpIncr = 3
InstructionOpUpdate = 4



#---- Constants from Go: Python can only ask that you please don't change these! ---
HandlerFuncName = "handler"


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface pyexp.Runtime
class Runtime(go.GoClass):
	"""Runtime is the starlark runtime for the PyExp.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = 0
	def DiscoverDependencies(self):
		"""DiscoverDependencies() []str, str"""
		return go.Slice_string(handle=_pyexp.pyexp_Runtime_DiscoverDependencies(self.handle))
	def Exec(self, arg_0):
		"""Exec(object) object, str"""
		return ExecResponse(handle=_pyexp.pyexp_Runtime_Exec(self.handle, arg_0.handle))
	def ExecWithEngine(self, ctx, req, e):
		"""ExecWithEngine(object ctx, object req, object e) object, str"""
		return ExecResponse(handle=_pyexp.pyexp_Runtime_ExecWithEngine(self.handle, ctx.handle, req.handle, e.handle))


# ---- Structs ---

# Python type for struct pyexp.InstructionsBag
class InstructionsBag(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.pyexp_InstructionsBag_CTor()
			_pyexp.IncRef(self.handle)
			if  1 < len(args):
				self.Instructions = args[1]
			if "Instructions" in kwargs:
				self.Instructions = kwargs["Instructions"]
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.InstructionsBag{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.InstructionsBag ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Instructions(self):
		return Slice_pyexp_Instruction(handle=_pyexp.pyexp_InstructionsBag_Instructions_Get(self.handle))
	@Instructions.setter
	def Instructions(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_InstructionsBag_Instructions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct pyexp.PyVal
class PyVal(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.pyexp_PyVal_CTor()
			_pyexp.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Timestamp = args[1]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
			if  2 < len(args):
				self.Fresh = args[2]
			if "Fresh" in kwargs:
				self.Fresh = kwargs["Fresh"]
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.PyVal{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.PyVal ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _pyexp.pyexp_PyVal_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_PyVal_Value_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_PyVal_Value_Set(self.handle, value)
	@property
	def Timestamp(self):
		return go.time_Time(handle=_pyexp.pyexp_PyVal_Timestamp_Get(self.handle))
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_PyVal_Timestamp_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Fresh(self):
		return _pyexp.pyexp_PyVal_Fresh_Get(self.handle)
	@Fresh.setter
	def Fresh(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_PyVal_Fresh_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_PyVal_Fresh_Set(self.handle, value)

# Python type for struct pyexp.BasicOp
class BasicOp(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.pyexp_BasicOp_CTor()
			_pyexp.IncRef(self.handle)
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.BasicOp{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.BasicOp ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct pyexp.ExecRequest
class ExecRequest(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.pyexp_ExecRequest_CTor()
			_pyexp.IncRef(self.handle)
			if  0 < len(args):
				self.Headers = args[0]
			if "Headers" in kwargs:
				self.Headers = kwargs["Headers"]
			if  1 < len(args):
				self.Payload = args[1]
			if "Payload" in kwargs:
				self.Payload = kwargs["Payload"]
			if  2 < len(args):
				self.EntityID = args[2]
			if "EntityID" in kwargs:
				self.EntityID = kwargs["EntityID"]
			if  3 < len(args):
				self.Timestamp = args[3]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
			if  4 < len(args):
				self.Logger = args[4]
			if "Logger" in kwargs:
				self.Logger = kwargs["Logger"]
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.ExecRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.ExecRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Headers(self):
		return Map_string_Slice_string(handle=_pyexp.pyexp_ExecRequest_Headers_Get(self.handle))
	@Headers.setter
	def Headers(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecRequest_Headers_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Payload(self):
		return any(handle=_pyexp.pyexp_ExecRequest_Payload_Get(self.handle))
	@Payload.setter
	def Payload(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecRequest_Payload_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def EntityID(self):
		return _pyexp.pyexp_ExecRequest_EntityID_Get(self.handle)
	@EntityID.setter
	def EntityID(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecRequest_EntityID_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_ExecRequest_EntityID_Set(self.handle, value)
	@property
	def Timestamp(self):
		return go.time_Time(handle=_pyexp.pyexp_ExecRequest_Timestamp_Get(self.handle))
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecRequest_Timestamp_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Logger(self):
		return go.logr_Logger(handle=_pyexp.pyexp_ExecRequest_Logger_Get(self.handle))
	@Logger.setter
	def Logger(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecRequest_Logger_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct pyexp.ExecResponse
class ExecResponse(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.pyexp_ExecResponse_CTor()
			_pyexp.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Timestamp = args[1]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
			if  2 < len(args):
				self.EntityID = args[2]
			if "EntityID" in kwargs:
				self.EntityID = kwargs["EntityID"]
			if  3 < len(args):
				self.Instructions = args[3]
			if "Instructions" in kwargs:
				self.Instructions = kwargs["Instructions"]
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.ExecResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.ExecResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return any(handle=_pyexp.pyexp_ExecResponse_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecResponse_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Timestamp(self):
		return go.time_Time(handle=_pyexp.pyexp_ExecResponse_Timestamp_Get(self.handle))
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecResponse_Timestamp_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def EntityID(self):
		return _pyexp.pyexp_ExecResponse_EntityID_Get(self.handle)
	@EntityID.setter
	def EntityID(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecResponse_EntityID_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_ExecResponse_EntityID_Set(self.handle, value)
	@property
	def Instructions(self):
		return Slice_pyexp_Instruction(handle=_pyexp.pyexp_ExecResponse_Instructions_Get(self.handle))
	@Instructions.setter
	def Instructions(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_ExecResponse_Instructions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct pyexp.Instruction
class Instruction(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pyexp.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pyexp.IncRef(self.handle)
		else:
			self.handle = _pyexp.pyexp_Instruction_CTor()
			_pyexp.IncRef(self.handle)
			if  0 < len(args):
				self.Operation = args[0]
			if "Operation" in kwargs:
				self.Operation = kwargs["Operation"]
			if  1 < len(args):
				self.FQN = args[1]
			if "FQN" in kwargs:
				self.FQN = kwargs["FQN"]
			if  2 < len(args):
				self.EntityID = args[2]
			if "EntityID" in kwargs:
				self.EntityID = kwargs["EntityID"]
			if  3 < len(args):
				self.Timestamp = args[3]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
			if  4 < len(args):
				self.Value = args[4]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_pyexp.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.Instruction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'pyexp.Instruction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Operation(self):
		return _pyexp.pyexp_Instruction_Operation_Get(self.handle)
	@Operation.setter
	def Operation(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_Instruction_Operation_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_Instruction_Operation_Set(self.handle, value)
	@property
	def FQN(self):
		return _pyexp.pyexp_Instruction_FQN_Get(self.handle)
	@FQN.setter
	def FQN(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_Instruction_FQN_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_Instruction_FQN_Set(self.handle, value)
	@property
	def EntityID(self):
		return _pyexp.pyexp_Instruction_EntityID_Get(self.handle)
	@EntityID.setter
	def EntityID(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_Instruction_EntityID_Set(self.handle, value.handle)
		else:
			_pyexp.pyexp_Instruction_EntityID_Set(self.handle, value)
	@property
	def Timestamp(self):
		return go.time_Time(handle=_pyexp.pyexp_Instruction_Timestamp_Get(self.handle))
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_Instruction_Timestamp_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Value(self):
		return any(handle=_pyexp.pyexp_Instruction_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_pyexp.pyexp_Instruction_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def PyExecReq(jsonPayload, p):
	"""PyExecReq(str jsonPayload, callable p) object, str"""
	return ExecRequest(handle=_pyexp.pyexp_PyExecReq(jsonPayload, p))


# ---- Functions ---
def PyTimeRFC3339(t):
	"""PyTimeRFC3339(object t) str"""
	return _pyexp.pyexp_PyTimeRFC3339(t.handle)
def JsonAny(o, field):
	"""JsonAny(object o, str field) str"""
	return _pyexp.pyexp_JsonAny(o.handle, field)
def New(program, fqn):
	"""New(str program, str fqn) object, str"""
	return Runtime(handle=_pyexp.pyexp_New(program, fqn))
def PyTime(str, layout):
	"""PyTime(str str, str layout) object, str"""
	return go.time_Time(handle=_pyexp.pyexp_PyTime(str, layout))


