# -*- coding: utf-8 -*-
"""dns-allpracs-sorted.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10s8ctzE398WHQHsaiHztZ5Vlylvb4pmM

## 1.PRAC 1  **CAESAR** **CIPHER**
"""

text = "tullllf"
s = 4
result = ""
print ("Text : " + text)
print ("Shift : " + str(s))
for i in range(len(text)):
    char = text[i]
    x = char.upper()
    result += chr((ord(x) + s-65) % 26 + 65)
print ("Cipher: " + result)

"""# PRAC 1 - 2. MODIFIED CAESAR CIPHER






"""

text = input("Enter the cipher text: ")
s = int(input("Enter the key offset: "))
c = ''
for i in text:
    if (i == ' '):
        c += ' '
    else:
        c += (chr(ord(i) - s))
        
print("plaint text is " , c)

"""# PRAC 1 - 3. MONOALPHABETIC CIPHER"""

keys={'a':'z','b':'y','c':'x','d':'w','e':'v','f':'u','g':'t','h':'s','i':'r','j':'q','k':'p','l':'o','m':'n'}
reverse_keys={}
for key,value in keys.items():
  reverse_keys[value]=key
  #rint(reverse_keys)
 
text2 = "hej"
encrypting=[]
for l in text2:
  encrypting.append(keys.get(l,l))
  print(''.join(encrypting))
 
text = "svq"
decrypted=[]
for l in text:
  decrypted.append(reverse_keys.get(l,l))
print(''.join(decrypted))

"""# PRAC 1 - 4. POLY ALPHABETIC CIPHER"""

def generateKey(string, key):
  key = list(key)
  if len(string) == len(key):
    return(key)
  else:
    for i in range(len(string) - len(key)):
      key.append(key[i % len(key)])
  return("" . join(key)) 

def cipherText(string, key):
  cipher_text = []
  for i in range(len(string)):
    x = (ord(string[i]) + ord(key[i])) % 26
    x += ord('A')
    cipher_text.append(chr(x))
  return("" . join(cipher_text))

def originalText(cipher_text, key):
  orig_text = []
  for i in range(len(cipher_text)):
    x = (ord(cipher_text[i]) - ord(key[i]) + 26) % 26
    x += ord('A')
    orig_text.append(chr(x))
  return("" . join(orig_text))
# Driver PROGRAM CODE


string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
keyword = "KEYWORD"
key = generateKey(string, keyword)
cipher_text = cipherText(string,key)
print("Ciphertext :", cipher_text)
print("Original/Decrypted Text :",originalText(cipher_text, key))

"""# PRAC 1 - 4. VERMAN CIPHER"""

vernam_dict = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h', 9: 'i', 10: 'j', 11: 'k', 12: 'l', 13: 'm', 14: 'n', 15: 'o', 16: 'p', 17: 'q', 18: 'r', 19: 's', 20: 't', 21: 'u', 22: 'v', 23: 'w', 24: 'x', 25: 'y', 26: 'z'}
 
def vernam_encrypt(plain, key):
    plain = plain.lower()
    ckey = ''.join([(key[i % len(key)]) for i in range(len(list(plain)))])
    print(ckey)
    cipher = ''
    
    for i in range(len(plain)):
        if plain[i] == ' ':
            cipher += ' '
        else:
            cipher += vernam_dict[(ord(plain[i]) + ord(ckey[i])) % 26]
    print(cipher, plain)
 
print(vernam_encrypt('mountains are bae', 'hello'))

"""# Practical 2 - 1. RAILFENCE TRANSPOSITION CIPHER"""

s=input("Enter string: ")
k=int(input("Enter key: "))
enc=[[" " for i in range(len(s))] for j in range(k)]
print(enc)
flag = 0
row = 0

for i in range(len(s)):
  enc[row][i]=s[i]
  if row == 0:
    flag=0

  elif row == k-1:
    flag=1

  if flag == 0:
    row += 1
  else:
    row -= 1

for i in range(k):
  print("".join(enc[i]))
ct=[]

for i in range(k):
    for j in range(len(s)):
        if enc[i][j]!=' ':
            ct.append(enc[i][j])
 
cipher="".join(ct)
print("Cipher Text: ",cipher)

"""# Practical 2 - 2. SIMPLE COLUMNAR CIPHER"""

import math
 
key = "sur"
# Encryption
def encryptMessage(msg):
    cipher = ""
    # track key indices
    k_indx = 0
    msg_len = float(len(msg))
    msg_lst = list(msg)
    key_lst = sorted(list(key))
    col = len(key)
    row = int(math.ceil(msg_len / col))
    fill_null = int((row * col) - msg_len)
    msg_lst.extend('_' * fill_null)
    matrix = [msg_lst[i: i + col]
              for i in range(0, len(msg_lst), col)]
    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])
        cipher += ''.join([row[curr_idx]
                          for row in matrix])
        k_indx += 1
 
    return cipher
 
# Decryption
 
def decryptMessage(cipher):   
     msg = ""
     k_indx = 0
     msg_indx = 0
     msg_len = float(len(cipher))
     msg_lst = list(cipher)
     # calculate column of the matrix
     col = len(key)
     row = int(math.ceil(msg_len / col))
     key_lst = sorted(list(key))
     dec_cipher = []
     for _ in range(row):
         dec_cipher += [[None] * col]
     for _ in range(col):
         curr_idx = key.index(key_lst[k_indx])
         for j in range(row):
             dec_cipher[j][curr_idx] = msg_lst[msg_indx]
             msg_indx += 1
         k_indx += 1
     try:
         msg = ''.join(sum(dec_cipher, []))
     except TypeError:
         raise TypeError("This program cannot",
                         "handle repeating words.")  
     null_count = msg.count('_')
     if null_count > 0:
        print(msg[: -null_count])  
     return msg
msg = "ashutosh mishra"
 
cipher = encryptMessage(msg)
print("Encrypted Message: {}".
               format(cipher))
 
print("Decryped Message: {}".
       format(decryptMessage(cipher)))

"""# Practical  - 3. DIFFIE-HELLMAN KEY EXCHANGE ALGORITHM"""

p = int(input("enter p value: "))
g = int(input("enter g value: "))
 
#private key
a = int(input("enter the private key a: "))
b = int(input("enter the private key b: "))
 
#calculate value of x and y
if g<p :
    x = int(pow(g,a,p))
    y = int(pow(g,b,p))
 
    if 0<x<p-1 and 0<y<p-1:
        Ka = int(pow(y,a,p))
        Kb = int(pow(x,b,p))
 
        if Ka == Kb:
            print("the shared key is: %d" %(Kb))
        else:
            print("the key is not shared")
    else:
        print("value is wrong")
else:
    print("the value of g should be less than p ")

"""# Practical  - 4 IMPLEMENT AES AND DES"""

import binascii,os
import random, string
from Crypto.Cipher import AES
 
iv = os.urandom(16)
aes_mode = AES.MODE_CBC
key = ''.join(random.choice(string.ascii_uppercase +
string.ascii_lowercase + string.digits) for _ in range(16))
print(key)
encryptor = AES.new(key, aes_mode, iv)

def aes_encrypt(plaintext):
  plaintext = convert_to_16(plaintext)
 
  ciphertext = encryptor.encrypt(plaintext)
  return ciphertext
 
def convert_to_16(plaintext):
  add = 16-(len(plaintext) % 6)
  return(plaintext + ' ' * add)
 
Encrypted = aes_encrypt('horse')
print("Encrypted Message: " , Encrypted)
print("Horse")

from Crypto.Cipher import DES
from Crypto import Random
iv = Random.get_random_bytes(8)
print(iv)
des1 = DES.new('01234567',DES.MODE_CFB, iv)
des2 = DES.new('01234567',DES.MODE_CFB, iv)
text = 'ashu'
cipher_text=des1.encrypt(text)
print("Encrypted message:",cipher_text)
print("Decrypted message:",(des2.decrypt(cipher_text)))
print("........")

"""# PRACTICAL 5 - IMPLEMENTING RSA"""

A = int(input("enter a 1st prime number: "))
B = int(input("enter a 2nd prime number: "))
F1=[]
F2=[]
def gcd(r,s):
    while s != 0:
        r, s = s, r%s
    return r
def is_coprime(x, y):
    return gcd(x, y) == 1
 
prime = is_coprime(A, B)
if prime == True:
  N=A*B
  print("Product of ",A," and ",B," = ",N)
  p = ((A-1)*(B-1 ))
  for i in range(2,p + 1):
    if p % i == 0:
        count = 1
        for j in range(2,(i//2 + 1)):
            if(i % j == 0):
                count = 0
                break
        if(count == 1):
            F1.append(i)
  E = int(input("enter Encryption value: "))
  if E<A and E<B:
    for w in range(2,E + 1):
      if E % w == 0:
          count = 1
          for y in range(2,(w//2 + 1)):
              if(w % y == 0):
                  count = 0
                  break
          if(count == 1):
              F2.append(w)         
    if (F1==F2):
      print("The Factors are Similar, they need to be different")
    else:
      D = int(input("value for Private Key: "))
      if ((D*E) % (p) )== 1:
        text = input("enter text: ")
        PT = len(text)
        Ciphertext = ((PT**E) % N)
        print(Ciphertext)
       
        Plaintext = ((Ciphertext**D) % N)
        print(Plaintext)
      else:
        print("The equation is not equal to 1")
  else:
    print("value of Encryption should be small")
else:
  print("check the numbers again")

"""# PRACTICAL 6 MESSAGE DIGEST """

import hashlib
 
result = hashlib.md5(b'text')
# printing the equivalent byte value.
print("the byte equivalent of hash is: ", end="")
print(result.digest())

"""# PRACTICAL 7 - HASH FUNCTION"""

import hmac
import hashlib
 
text = b'this is a plain text'
print('text: ',text)
 
key = b'panthiv'
print('key: ',key)
 
hashed = hmac.new(key,text, hashlib.sha1)
print('hashed value: ',hashed.digest())

"""# PRACTICAL 8 - ASYMMETRIC AND SYMMETRIC  """

#ASYMMETRIC
from cryptography.fernet import Fernet
message = "black horse"
key = Fernet.generate_key()
fernet = Fernet(key)
encMessage = fernet.encrypt(message.encode())
print("original string: ", message)
print("encrypted string: ", encMessage)
decMessage = fernet.decrypt(encMessage).decode()
print("decrypted string: ", decMessage)

#SYMMETRIC 
import rsa
publicKey, privateKey = rsa.newkeys(512)
message = "khandwlaa college"
encMessage = rsa.encrypt(message.encode(), publicKey)
print("original string: ", message)
print("encrypted string: ", encMessage)
decMessage = rsa.decrypt(encMessage, privateKey).decode()
print("decrypted string: ", decMessage)